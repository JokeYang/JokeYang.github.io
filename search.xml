<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[服务器虚拟化-工作总结]]></title>
      <url>%2F2017%2F12%2F28%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%99%9A%E6%8B%9F%E5%8C%96%2F</url>
      <content type="text"><![CDATA[引言&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[光与影 —— 在路上]]></title>
      <url>%2F2017%2F02%2F18%2F%E5%85%89%E4%B8%8E%E5%BD%B1%2F</url>
      <content type="text"><![CDATA[最近，一直待在家里没有出门，除了看看书就是听听歌。好在最近天气不错，阳光正好。慵懒地晒着太阳，十分的惬意。光影下的一树一草，更是让我脑海中闪过一幅幅的风景画。画面中，阳光柔和。 光与影 —— 故宫背着相机在胡同里穿行，一路从南锣鼓巷走到故宫。 在故宫的一隅，光与影、天与水交织，那样的恰到好处，吸引着过往的人驻足。 景山上远眺故宫 … 光与影 —— 江南小镇田间的绿色让人心旷神怡，而远处山上的那座塔，更让人向往 … 沿着田间的小路往前走，忽然间远处飘来一阵汽笛声。沿着声音的方向走去，眼前出现了一番别样的景致。站在河道旁的垂柳下，望着不远处山上的那座塔，越发的想前去探个究竟 … 带着好奇心，来到了塔下 … 光与影 —— 一座小城工作的第二个月，第一次独立出差，河北的一个小城。刚下火车 … 出差结束，回北京。在站台等火车 … 在站台等待的时间… 也许是风景正好，才踌躇了一小会，抬头一看，太阳就要下山了。黄昏的阳光是那样的温馨 … 光与影 —— 路边的花雨后的校园 … 白羊沟，大山的深处 … 西湖边 … 在路上，总有风景等你发现 …]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据库笔记]]></title>
      <url>%2F2017%2F02%2F15%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[引言 毕业之后就一直没怎么碰到和使用过数据库，数据库就只记得一个指令 SELECT &amp;lowast FROM xx WHERE xx 。最近正好有个面试，复习一下数据库这部分的知识，做一个总结。 一、数据库的一些概念数据库的概念： 数据库指的是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。 数据库管理系统： 数据库管理系统（Database Management System，简称DBMS）是为管理数据库而设计的电脑软件系统，一般具有存储、截取、安全保障、备份等基础功能。例如:MySQL就是一个数据库管理系统。 关系数据库： 所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。 关系数据库管理系统的特点： 数据以表格的形式出现; 每行为各种记录名称; 每列为记录名称所对应的数据域; 许多的行和列组成一张表单; 若干的表单组成 database; 关系模型的结构的一些概念： 表的结构 表 关系模型的数据结构单一，采用二维表结构来表示实体和实体之间的关系，是一种按行与列排列的具有相关信息的逻辑组。一个关系对应一个二维表。一个数据库可以包含任意多个数据表。 属性 表中每一列（也称字段、数据项）描述实体集的某个特征，在关系数据库中被称为属性；每一个属性都有自己的取值范围，称为域。 元组 表中的每一行由一个实体的相关属性取值构成，称为元组，它相对完整地描述了一个实体。一个元组在关系数据库中也被称为一条记录。元组的一个属性值称为分量。 关键字 在一个关系模式中，关键字是保证表中记录具有唯一性的一种机制。 候选关键字 关系表中按应用语义能唯一标志元组的最小属性的集合。在最简单的情况下，候选关键字只包含一个属性。在最极端的情况下，关系模式的所有属性组是这个关系模式的候选关键字，称为全码。 主关键字（主键） 用户指定的用来在关系表中唯一标识元组的一个候选关键字。若一个关系有多个候选关键字，则只选定其中的一个为主关键字。主关键字的值不能为空、不能重复。 外关键字 （外键） 一个表中的主关键字与另一个表中与该主关键字相同的属性建立联系，这个起到联系作用的属性，称为另一个表的外关键字，简称外键。 关系模式 表中的行定义（即表头）是实体集相关属性的集合，称为该表的关系模式。关系模式就是对关系的描述，包括关系名、组成该关系的属性名、属性向域的映像。 关系模式通常记为：(属性名1,属性名2,…属性名n)，其中主关键字加下划线。 二、关系数据库的基本操作关系数据库的基本操作包括：查、增、删、改。这些操作，我们可以通过一种语言去执行，这种语言就是 SQL （Structured Query Language），即结构化查询语言。 SQLSQL 是一门 ANSI 的标准计算机语言，用来访问和操作数据库系统。SQL 语句用于取回和更新数据库中的数据。 数据操作语言 (DML) SQL (结构化查询语言)是用于执行查询的语法。但是 SQL 语言也包含用于更新、插入和删除记录的语法。查询和更新指令构成了 SQL 的 DML 部分： SELECT - 从数据库表中获取数据 UPDATE - 更新数据库表中的数据 DELETE - 从数据库表中删除数据 INSERT INTO - 向数据库表中插入数据 数据定义语言 (DDL) SQL 的数据定义语言 (DDL) 部分使我们有能力创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。SQL 中最重要的 DDL 语句: CREATE DATABASE - 创建新数据库 ALTER DATABASE - 修改数据库 CREATE TABLE - 创建新表 ALTER TABLE - 变更（改变）数据库表 DROP TABLE - 删除表 CREATE INDEX - 创建索引（搜索键） DROP INDEX - 删除索引 SQL指令SELECT SELECT 最常用的方式是将数据从数据库中的表中选出，即从 (FROM) 数据库中的表中选出 (SELECT)。(表格是一个数据库内的结构，它的目的是储存数据。)一个最基本的 SQL 架构如下所示： SELECT “列名” FROM “表名称” 例如： 1SELECT Name FROM city 上述语句，会返回表 city 中的 Name 这一列的全部值。 DISTINCT SELECT 指令让我们能够读取表中一个或数个列的所有数据，得到的数据的值可能会有重复。当我们需要找出表中的某列数据有哪些不同的值时，只要在 SELECT 后加上一个 DISTINCT 就可以了。也就是说 SELECT 会将符合条件的数据全都选出来，而 DISTINCT 会选择出这个表的列中那些 不同的值。即使每个值的出现多次，使用 DISTINCT 后会返回唯一不同的值。在 SQL 中，使用 DISTINCT 的语法如下： SELECT DISTINCT “列名” FROM “表名称” 例如： 1SELECT DISTINCT Language FROM countrylanguage 上述语句，会返回表 countrylanguage 中的属性 Language 这一列在表中的不同的值。 WHERE 当我们需要选择性地从表中选取数据时，就需要用到 WHERE 这个指令。使用 WHERE 指令的语法如下： SELECT “列名称” FROM “表名称” WHERE “条件”（列 运算符 值） 例如： 1SELECT CountryCode FROM countrylanguage WHERE Language = "English" 上述语句，会返回表 countrylanguage 中 Language 的值为 Enlish 的 CountryCode 的列。 AND OR 上面的指令都是基于一个条件对数据进行选择，当我们想通过复杂条件选择数据时，可以将多个简单条件连接成复杂条件。拿 WHERE 来说，AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。使用 AND OR 指令的语法如下： SELECT “列名” FROM “表名称” WHERE “简单条件” {[AND|OR] “简单条件”}+ 例如： 1SELECT CountryCode FROM countrylanguage WHERE Language = English AND IsOfficial = "T" 上述语句，会返回表 countrylanguage 中 Language 的值为 Enlish 且 IsOfficial 为 T 的列。 IN IN 这个指令允许我们在 WHERE 子句中规定多个值。IN 指令的语法为下： SELECT “栏位名” FROM “表名称” WHERE “列名” IN (‘值一’, ‘值二’, …) 例如： 1SELECT CountryCode FROM countrylanguage WHERE Language IN ("Enlish","French") 上述命令，会返回表 countrylanguage 中 Language 的值满足条件在 Enlish 和 French 这两个值中的列。 BETWEEN BETWEEN 操作符在 WHERE 子句中使用，经常和 AND 连用。使用 BETWEEN … AND 选取介于两个值之间的数据范围。这些值可以是数值、文本或者日期。。BETWEEN 这个子句的语法如下： SELECT “列名” FROM “表名称” WHERE “列名” BETWEEN ‘值一’ AND ‘值二’ 例如： 1SELECT CountryCode FROM countrylanguage WHERE Percentage BETWEEN "10.0" AND "35.0" 上述语句，会返回表 countrylanguage 中 Percentage 值在 10.0 到 35.0 之间的列。 LIKE LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式(pattern)。对比之下，在使用 IN 指令的时候，我们完全地知道我们需要的条件；在使用 BETWEEN 指令的时候，我们则是列出一个范围。使用 LIKE 指令的语法如下： SELECT “列名” FROM “表名称” WHERE “列名” LIKE {模式} 例如： 1SELECT CountryCode FROM countrylanguage WHERE CountryCode LIKE "%A%"; 上述语句，会返回表 countrylanguage 中 CountryCode 以A开头的列。LIKE 后的模式，通常是一个通配符。 ORDER BY ORDER BY 语句用于根据指定的列对结果集进行排序,默认按照升序（ASC）对记录进行排序。如果希望按照降序对记录进行排序，可以使用 DESC 关键字。ORDER BY 的语法如下: SELECT “列名” FROM “表名称” [WHERE “条件”] ORDER BY “列名” [ASC, DESC] 例如： 1SELECT CountryCode,Percentage FROM countrylanguage WHERE Percentage BETWEEN "25.0" AND "55.0" ORDER BY Percentage DESC 上述语句，会返回表 countrylanguage 中包含 CountryCode 和 Percentage 的列，这些列按照 Percentage 的值降序排列，且满足 Percentage 值介于25.0和55.0之间。 函数 除了对数据的查询，我们有的时候可能会想对这些数据做一些运算，比如将它们总合起来，或是找出它们的平均值，而SQL 有提供一些这一类的函数。 AVG (平均) COUNT (计数) MAX (最大值) MIN (最小值) SUM (总合) 使用函数的语法是： SELECT “函数名”(“列名”) FROM “表名称” 例一： 1SELECT SUM(Population) FROM city WHERE CountryCode = "AFG" 上述语句，会返回表 city 中 CountryCode 等于 AFG 的 Population 总合。 例二： 1SELECT COUNT(CountryCode) FROM city WHERE CountryCode = "NLD" 上述语句，会返回表 city 中 CountryCode 等于 NLD 的个数。 例三： 1SELECT COUNT(DISTINCT CountryCode) FROM city WHERE CountryCode IS NOT NULL 上述语句，会返回表 city 中 CountryCode 的个数。COUNT 和 DISTINCT 经常被合起来使用，目的是找出表中某列有多少不同的数值。 例四： 1SELECT AVG(Population) FROM city WHERE CountryCode = "DZA" 上述语句，会返回表 city 中 CountryCode 等于 DZA 的Population 的平均值。 GROUP BY GROUP BY 语句用于结合合计函数 (比如 SUM)，根据一个或多个列对结果集进行分组。使用 GROUP BY 的语法为： ELECT “列名1”, SUM(“列名2”) FROM “表名称” GROUP BY “列名1” 例如：1SELECT CountryCode,SUM(Population) FROM city GROUP BY CountryCode 上述语句，会返回表 city 中 每个 CountryCode 对应的总人数，结果按照 CountryCode 进行分组。 HAVING 当我们想对函数产生的值来设定条件时，比如我们想知道那个 CountryCode 的总人数超过10000000，在这个情况下，我们不能使用 WHERE 的指令。这时，我们可以使用 HAVING 的指令，来达到这个目标。 需要注意的是 HAVING 子句通常是在一个 SQL 句子的最后；而且，一个含有 HAVING 子句的 SQL 并不一定要包含 GROUP BY 子句。使用 HAVING 的语法如下： SELECT “列名1”, SUM(“列名2”) FROM “表名称” GROUP BY “列名1” HAVING (函数条件) 例如：1SELECT CountryCode,SUM(Population) FROM city GROUP BY CountryCode HAVING SUM(Population) &gt; "10000000" 上述语句，会返回表 city 中 Population 总数大于10000000的结果，结果按照 CountryCode 进行分组。 ALIAS 在 SQL 语言中，可以通过 ALIAS 为列名称和表名称指定别名。最常用到的别名有两种：列别名及表别名。SQL 中使用列名和表别名的语法如下： SELECT “表别名”.”列名1” “列别名” FROM “表名称” “表别名” 例如：1SELECT c1.District Area FROM city c1 GROUP BY c1.District 上述语句，会返回表 city 中的 District 这一列。不同的是，返回的结果中 District 这一列有了别名 Area。 表连接 之前，我们都是在一张表中读取数据，操作相对比较简单。但实际情况下，我们经常需要从多个数据表中读取数据。在 SQL 中，JOIN 用于根据两个或多个表中的列之间的关系，从这些表中查询数据。 在 MySQL 中 JOIN 按照功能大致分为如下三类： INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。 LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。 RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。 要能进行多表查询，那么被查询的表之间必须要有联系，而数据库中的表可通过键将彼此联系起来。 主键（Primary Key）是一个列，在这个列中的每一行的值都是唯一的。在表中，每个主键的值都是唯一的。这样做的目的是在不重复每个表中的所有数据的情况下，把表间的数据交叉捆绑在一起。 例如：12345678SELECT c1. NAME CountryName, c2. LANGUAGE Country_LanguageFROM city c1INNER JOIN countrylanguage c2 ON c1.CountryCode = c2.CountryCodeGROUP BY c1. NAME 注： INNER JOIN 与 JOIN 是相同的。 表格处理前面我们基本都是在数据库管理系统中存在数据库的情况下，获取数据库中的数据。当然，我们也可以自己创建数据库，根据自己的需要建表存储数据。 CREATE DATABASE 在 SQL 中，使用 CREATE DATABASE 来创建数据库。使用的语法 CREATE DATABASE 语法如下： CREATE DATABASE database_name 例如：1CREATE DATABASE store 上述语句，创建了一个名叫 store 的数据库。 CREATE TABLE 创建好数据库，我们就需要建立表格来存储数据。使用 CREATE TABLE 的语法是： CREATE TABLE 表名称 ( 列名称1 数据类型, 列名称2 数据类型, 列名称3 数据类型, …. ) 例如：12345678CREATE TABLE Customer( Id int, First_Name char(50), Last_Name char(50), Address char(50), City char(50), Country char(25), Birth_Date date ) 上述语句，创建了一个名叫 Customer 的表,并定义了表中存储数据。 在创建表时，我们需要对表中要存储的数据进行限制，常见的限制有以下几种： NOT NULL UNIQUE CHECK Primary Key Foreign Key NOT NULL 在没有做出任何限制的情况下，某一列的值是允许有 NULL 值的。如果我们不允许某一列的值含有 NULL 值，我们就需要对那个列做出 NOT NULL 的指定。 例如：1234CREATE TABLE Customer( SID integer NOT NULL, Last_Name varchar (30) NOT NULL, First_Name varchar(30)); 上述语句，”SID” 和 “Last_Name” 这两列不允许有 NULL 值，而 “First_Name” 这一列是可以有 NULL 值的。 UNIQUE UNIQUE 限制是保证一个栏位中的所有资料都是有不一样的值。 例如：1234CREATE TABLE Customer( SID integer Unique, Last_Name varchar (30), First_Name varchar(30)); 上述语句，”SID” 这列不能有重复值存在，而 “Last_Name” 及 “First_Name” 这两列则是允许有重复值存在。 注意：一个被指定为主键的列也一定会含有 UNIQUE 的特性。相对来说，一个UNIQUE 的列并不一定会是一个主键。 CHECK CHECK 约束用于限制列中的值的范围。如果对单个列定义 CHECK 约束，那么该列只允许特定的值。如果对一个表定义 CHECK 约束，那么此约束会在特定的列中对值进行限制。 例如：1234CREATE TABLE Customer( SID integer CHECK (SID &gt; 0), Last_Name varchar (30), First_Name varchar(30)); 上述语句，”SID” 这列的值只能包含大于 0 的整数。 注意：CHECK 限制目前尚未被执行于 MySQL 数据库上。 Primary Key 主键（Primary Key）在前面已经多次提到了，它是一个列，在这个列中的每一行的值都是唯一的。在表中，每个主键的值都是唯一的。这样做的目的是在不重复每个表中的所有数据的情况下，把表间的数据交叉捆绑在一起。主键可以是表中的一个列，或是一个人造列 (与表没有关系的列)。主键可以包含一或多个列。当主键包含多列时，称为组合键 (Composite Key)。 主键可以在创建新表时设定 (使用 CREATE TABLE 语句)，或是以改变现有表架构的方式设定 (使用 ALTER TABLE)。例如，MySQL 中指定 Primary Key：12345CREATE TABLE Customer( SID integer, Last_Name varchar(30), First_Name varchar(30), PRIMARY KEY (SID)); 或者是改变现有表架构的方式设定：1ALTER TABLE Customer ADD PRIMARY KEY (SID); Foreign Key 外键（Foreign Key）是一个(或数个)指向另外一个表格主键的列。外键的目的是确定资料的参考完整性(referential integrity)。也就是说，只有被准许的资料值才会被存入数据库内。 例如，MySQL 中设置 Foreign Key：1234567CREATE TABLE ORDERS( Order_ID integer, Order_Date date, Customer_SID integer, Amount double, Primary Key (Order_ID), Foreign Key (Customer_SID) references CUSTOMER(SID)); 同样的，在建好表之后，我们依然可以通过改变现有表架构的方式设定外键：1ALTER TABLE ORDERS ADD FOREIGN KEY (customer_sid) REFERENCES CUSTOMER(sid); CREATE VIEW 在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。SQL中，建立一个视图的语法如下： CREATE VIEW view_name AS SELECT column_name(s) FROM table_name WHERE condition 例如：1CREATE VIEW New_City AS SELECT Name,District,Population FROM city 这样，我们就有了一个名为 New_City 的视图。当然，我们可以从视图中获取数据：1SELECT * FROM New_City CREATE INDEX INDEX （索引）是由一个表中的一列或者若干列的值与其对应的记录在数据表中地址所组成。用户无法看到索引，它们只能被用来加速搜索/查询。 数据库中一个表的存储由两部分组成：数据页面和索引页面。 创建索引的目的是为了改善查询性能、加快依据索引字段对表中数据行的检索、强制保持表的数据唯一性等。 索引虽然能改善查询性能，但也耗费了磁盘空间，并且当对数据表进行数据增加、修改或删除时，系统需要花费一些时间来维护索引，所以通常不在一个表上建立太多索引，也不建立不常使用的索引。 一般来说，需要在下面这些地方建立索引： 在主键和外键上创建索引 在检索频繁的字段建立索引 在经常需要排序的字段上建立索引 在 SQL 中，建立索引的语法如下： CREATE INDEX “INDEX_NAME” ON “TABLE_NAME” (COLUMN_NAME) 例如：1CREATE INDEX IDX_POPULATION ON city (Population) 注意索引的命名并没有一个固定的方式。通常会用的方式是在名称前加一个字首，例如”IDX_” ，来避免与数据库中的其他物件混淆。另外，在索引名之内包括表名及列名也是一个好的方式。 ALTER TABLE 在表被建立在数据库中后，我们常常会发现，这个表的结构需要有所改变。比如，增加一列、删去一列、改变列名称、改变列的数据类型。在 SQL 中， ALTER TABLE 语句用于在已有的表中添加、修改或删除列。使用 ALTER TABLE 的语法如下： ALTER TABLE “table_name” [ 改变方式 ] [ 改变方式 ] 的详细写法会依我们想要达到的目标而有所不同。比如，增加一列：1ALTER TABLE city ADD Country char(10) 删除一列：1ALTER TABLE city Drop Country 改变列的类型：1ALTER TABLE city Modify Country char(5) DROP 通过使用 DROP 语句，可以轻松地删除索引、表和数据库。 例如，删除一个表：1DROP TABLE city 或者是删除一个索引：1DROP INDEX IDX_POPULATION TRUNCATE TABLE 使用 DROP TABLE 指令会删除表和表中的数据。而使用 TRUNCATE TABLE 的指令，表中的数据会完全消失，可是表本身会继续存在。 TRUNCATE TABLE 的语法为下： TRUNCATE TABLE “表格名” 例如：1TRUNCATE TABLE city INSERT INTO 到目前为止，我们都是操作如何把数据从表中取出。那么，怎么往表中添加数据呢？在 SQL 中，我们可以通过 INSERT INTO 向表中添加数据。使用 INSERT INTO 的语法如下： INSERT INTO “表格名” (“列1”, “列2”, …) VALUES (“值1”, “值2”, …) 或者,将其它表中的数据作为值： INSERT INTO “表格1” (“栏位1”, “栏位2”, …) SELECT “栏位3”, “栏位4”, … FROM “表格2” 例如：1INSERT INTO city (Name,CountryCode,District,Population) VALUES ("NanJing","CHN","JiangSu",82302000) UPDATE 我们有时候可能会需要修改表格中的数据。在这个时候，我们就需要用到 UPDATE 指令。这个指令的语法是： UPDATE “表名” SET “列名1” = [新值] WHERE {条件} 例如：1UPDATE city SET Population = "1880000" WHERE Name = "Kabul" AND CountryCode = "AFG" DELETE FROM 在某些情况下，我们会需要直接从数据库中去除一些数据。在 SQL 可以通过 DELETE FROM 指令来完成。它的语法是： DELETE FROM “表格名” WHERE {条件} 例如：1DELETE FROM city WHERE Name = "MaiJi" 进阶SQLUNION UNION 操作符用于合并两个或多个 SELECT 语句的结果集。UNION 的语法如下： [SQL 语句 1] UNION [SQL 语句 2] 例如：1SELECT CountryCode FROM city UNION SELECT CountryCode FROM countrylanguage UNION ALL UNION ALL 这个指令的目的也是要将两个 SQL 语句的结果合并在一起。 UNION ALL 和 UNION 不同之处在于 UNION ALL 会将每一笔符合条件的数据都列出来，无论资料值有无重复。UNION ALL 的语法如下： [SQL 语句 1] UNION ALL [SQL 语句 2] 例如：1SELECT CountryCode FROM city UNION ALL SELECT CountryCode FROM countrylanguage INTERSECT 和 UNION 指令类似，INTERSECT 也是对两个 SQL 语句所产生的结果做处理的。不同的地方是，UNION 是对结果做并集，而 INTERSECT 是交集。INTERSECT 的语法如下： [SQL 语句 1] INTERSECT [SQL 语句 2] 注： MySQL 中无此用法 MINUS MINUS 指令是运用在两个 SQL 语句上。它先找出第一个 SQL 语句所产生的结果，然后看这些结果有没有在第二个 SQL 语句的结果中。如果有的话，那这一笔数据就被去除，而不会在最后的结果中出现。如果第二个 SQL 语句所产生的结果并没有存在于第一个 SQL语句所产生的结果内，那这笔数据就被抛弃。MINUS，也就是差集。使用 MINUS 的语法如下： [SQL 语句 1] MINUS [SQL 语句 2] 注： MySQL 中无此用法 子查询 我们可以在一个 SQL 语句中放入另一个 SQL 语句。当我们在 WHERE 子句或 HAVING 子句中插入另一个 SQL 语句时，我们就有一个子查询 (subquery) 的架构。 子查询的作用是什么呢？第一，它可以被用来连接表。另外，有的时候子查询是唯一能够连接两个表格的方式。子查询的语法如下： SELECT “栏位1” FROM “表格” WHERE “栏位2” [ 比较运算素 ](SELECT “栏位1” FROM “表格” WHERE [ 条件 ]) [ 比较运算素 ] 可以是相等的运算素，例如 =, &gt;, &lt;, &gt;=, &lt;=. 这也可以是一个对文字的运算素，例如 “LIKE”。绿色的部分代表外查询，红色的部分代表内查询。 例如：1SELECT SUM(Population) FROM city WHERE CountryCode IN (SELECT CountryCode FROM countrylanguage WHERE Language = "French") EXISTS 上面的子查询中，我们用 IN 来连接内查询和外查询,而 EXISTS 也是这样一种方式。在 SQL 中 EXISTS 是用来测试内查询有没有产生任何结果。如果有的话，系统就会执行外查询中的 SQL。若是没有的话，那整个 SQL 语句就不会产生任何结果。EXISTS 的语法是： SELECT “栏位1” FROM “表格1” WHERE EXISTS (SELECT *FROM “表格2” WHERE [条件]) 例如：1SELECT SUM(Population) FROM city WHERE EXISTS(SELECT * FROM countrylanguage WHERE Language = "French") CASE CASE 是 SQL 用来做为 if-then-else 之类逻辑的关键字。 CASE 的语法如下： SELECT CASE (“栏位名”) WHEN “条件1” THEN “结果1” WHEN “条件2” THEN “结果2” … [ELSE “结果N”] END FROM “表格名” 注意： “条件” 可以是一个数值或是公式。 ELSE 子句则并不是必须的。 例如：123456789SELECT NAME,CASE WHEN 'NanJing' THEN Population * 0.9WHEN 'TianShui' THEN Population * 1.1ELSE PopulationEND "New Population"FROM city 说明： 练习 SQL 语句的数据库结构及数据 在这里。数据库管理系统使用的是 MySQL。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GitHub 学习笔记]]></title>
      <url>%2F2017%2F01%2F04%2FGitHub%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[引言 很早之前就听说过和使用过 GitHub，那时仅仅是在 GitHub 上下载一些优秀的项目。最近有时间，正好可以比较全面的对 GitHub 做一个了解，学习如何熟练地使用 GitHub。 一、认识 GitHubGitHub 是一个通过 Git 进行版本控制的软件源代码托管服务。通过 GitHub 提供的 Git 仓库的托管服务，可以让我们和其他人轻松地分享代码。GitHub 为开发者或团队主要提供了以下的功能： Git仓库 一般情况下，我们可以免费建立任意个 GitHub 提供的 Git 仓库。如果需要建立只对特定任务或只对自己公开的私有仓库，则需要付费。 Organization Organization 账户可以统一管理账户和权限。 Issue Issue 功能，是将一个任务或问题分配给一个 Issue 进行追踪和管理的功能。在使用中，项目每一个功能更改或修改都对应一个 Issue，讨论或修正都以这个 Issue 为中心进行。只要查看 Issue，就能知道和这个更改相关的一切信息，并以此进行管理。 Wiki Wiki 功能，可以让任何人都能随时对一篇文章进行更改并保存，这样，就可以允许多人协同来完成一篇文章。Wiki 功能常用在开发文档或手册的编写中。 Pull Request 开发者向 GitHub 的仓库推送更改或功能添加后，可以通过 Pull Request 功能向别人的仓库提出申请，请求对方合并。 通过这些功能，能够帮助开发者和团队高效率、高品质的进行代码编写。 GitHub 与 Git 的区别：GitHub 和 Git 是完全不同的两个东西。在 Git 中，开发者将源代码存入名叫 “Git 仓库” 的资料库中并加以使用。而 GitHub 则是在网络上提供 Git 仓库的一项服务。也就是说，GitHub 上公开的软件源代码全都由 Git 进行管理。 二、Git 的安装Git 仓库管理功能是 GitHub 的核心。而在使用 GitHub 之前，除了掌握 Git 相关知识，还需要在本地的设备上安装 Git 的环境。 2.1 版本管理Git 属于分散型版本管理系统，是一款为版本管理而设计的软件。所谓 版本管理 ，就是管理更新的历史记录。通过版本控制提供的功能，我们可以在软件开发的过程中做到：记录一款软件添加或更改源代码的过程，回滚到特定阶段，恢复误删除的文件等。 2.2 版本管理系统的类型版本管理系统分为 Subversion 这类 集中型 的与 Git 这类 分布型 的。 集中型集中型，顾名思义，就是将仓库集中存放在服务器中，所以只存在一个仓库。集中型将所有数据集中存放在服务器当中，有便于管理的优点。但是一旦开发者所处的环境不能连接服务器或者服务器宕机，就无法获取最新的源代码，开发也就无法进行。特别的，当服务器故障导致数据消失，那么，开发者将无法在获得最新的源代码。 分布型分步型，相比于集中型，拥有多个仓库。而且，由于本地的开发环境中就有仓库，所以开发者不必连接远程仓库就可以进行开发。以 Git 为代表的分布型，Github 将仓库 Fork 给了每一个用户。Fork 就是将某个特定仓库复制到自己的账户下。Fork 出的仓库与原仓库是两个不同的仓库，开发者可以随意编辑。 2.3 安装2.3.1 Mac 与 Linux在最近的 Mac 中都预装了 Git，而各个版本的 Linux 中都也以软件包（Package）的形式提供给用户，所以我们可以直接使用。 2.3.2 Windows在 Windows 环境下，最简单快捷的方法是使用 msysGit 下载安装包。安装包下载完成以后，只要双击运行，按照向导一步步安装即可。在安装完成以后，我们需要对本地计算机里安装的 Git 进行如下的初始设置： 设置姓名和邮箱 12git config --global user.name &quot;your name&quot;` git config --global user.email &quot;your_email@example.com&quot; 上述的命令，会在 “~/.gitconfig” 中以如下的形式输出设置文件：123[user] name = your name email = your_email@example.com 通过直接编辑上述设置文件，我们就可以更改姓名和邮箱信息。 提高命令输出的可读性 将 color.ui 设置为 auto 可以让命令的输出拥有更高的可读性。1git config --global color.ui auto 运行上述命令之后，“~/.gitconfig” 配置文件中会增加下面一行：12[color] ui = auto 而通过这样的设置，各种命令的输出就会变得更加容易分辨。 三、使用 Github 的前期准备3.1 创建 Github 账户访问 Github官网 即可免费创建账户。在创建账户时，Username 一栏中用英文和数字设置自己喜欢的 ID。创建账户成功以后，这个 ID 就是你的公开页面的 URL。 3.2 设置 SSH KeyGithub 上连接已有仓库时的认证，是通过使用 SSH 的公开密钥认证的方式进行。 生成 SSH Key 运行下面的命令就可以创建 SSH Key：1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 运行完上述命令之后，执行 clip &lt; ~/.ssh/id_rsa.pub 或者到运行命令的过程中出现的路径里去打开文件并复制 SSH Key： 添加 SSH Key登录 Github，点击右上角的账户设定按钮，选择 Settings，在打开的页面中，点击左边的 SSH and GPG keys,然后选择右上角的 New SSH Key，将复制的 SSH Key 粘贴到 Key 输入框，Title 框中可以输入适当的密钥名称，完成后，点击下面的 Add SSH key 就成功了： 添加成功以后，我们需要测试一下，执行下面的命令：1ssh -T git@github.com 当出现如下结果，即为成功： 3.3 创建远程仓库点击右上角工具栏里的 New repository 图标，选择 New repository，创建新的仓库： 接着，在 Repository name 栏中输入仓库的名称： 点击 Create repositiry 按钮，完成仓库的创建。 3.4 创建版本库版本库即 .git 目录。版本库你可以简单的理解成一个文件夹，在这个文件夹里的所有文件都可以被 Git 管理起来。包括每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。创建一个版本库非常简单，首先，选择一个合适的地方，比如自己计算机下的某个盘，创建一个空目录即可。这里，我们以一个现有的项目为例子，例如： 我们在 G:\My Repository\NJUPT 目录下，运行以下命令 git init ，如下： 运行完上述命令后，瞬间 Gi t就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），同时，可以发现在 G:\My Repository\NJUPT 目录下多了一个 .git 的目录，这个目录是 Git 来跟踪管理版本库的。注意不要随意修改这个目录里面的文件，不然可能会破坏 Git 仓库。（如果你没有看到.git目录，那是因为这个目录默认是隐藏的） 接下来，我们将项目的包含的所有文件都添加到仓库： 然后，把文件提交到仓库，双引号内是对此次提交的注释。如下所示： 这样，本地仓库就建立好了。 总结： 初始化一个 Git 仓库，使用 git init 命令； 添加文件到Git仓库，分两步： 第一步，使用以下命令添加文件： 12git add &lt;file&gt; //添加单个文件；也可反复多次使用，添加多个文件git add . //将当前目录下所有文件添加 第二步，使用命令 git commit &quot;xxx&quot; ，提交文件。 3.5 将本地仓库的项目上传到 Github 远程仓库3.5.1 关联本地仓库与远程仓库首先，我们到 Github 上创建的仓库 Android_Bmob_Demo 复制仓库地址： 然后，执行命令：1git remote add origin https://github.com/JokeYang/Android_Bmob_Demo.git 3.5.2 上传本地项目到远程仓库接着，执行命令 git push -u origin master 上传本地项目代码，如下所示： 完成后，本地项目代码就已经推送到 Github 远程仓库，我们可以看到： 注意：git 是不能管理空的文件夹的，文件夹里必须有文件才能add，空的文件夹是不会被上传。 3.6 从远程库克隆上面我们讲述的是如何在有了本地库的情况下，创建远程库并将本地库与远程库关联。假如我们打算从零开始开发一个项目，同时打算将项目托管到 Github，我们在要做的是先创建远程库，然后，从远程库克隆。克隆一个远程库使用 git clone 命令，命令后面是项目的地址，如下所示： 当我们多个人协作开发或者我们要下载别人的项目时，就可以使用 git clone 命令从远程仓库克隆一份代码。 四、开始使用 Git4.1 基本操作 git init —— 初始化仓库要使用 Git 进行版本管理，必须先初始化仓库。我们只要建立一个目录，进入该目录，通过 git init 命令，即可让目录变成仓库。如果初始化成功，执行了 git init 命令的目录下就会生成 .git 目录。这个 .git 目录里存储着当前目录内容所需的仓库数据。在 Git 中，.git 目录的内容被称为 “附属于该仓库的工作树。 git status —— 查看仓库状态git status 命令用于显示 Git 仓库的状态。在工作的过程中，我们使用 git status 命令，可以时刻掌握仓库当前的状态。 git add —— 向暂存区中添加文件要想让文件成为 Git 仓库的管理对象，就需要用 git add 命令将其加入暂存区（Stage 或者 Index）中。暂存区是提交之前的一个临时区域。 git commit —— 保存仓库的历史记录git commit 命令可以将当前暂存区中的文件实际保存到仓库的历史记录中。通过这些记录，我们就可以在工作树中复原文件。git commit 命令一般的格式是：git commit -m &quot;First commit&quot;, -m 参数后的 “First commit” 称作提交信息，是对这个提交的概述。 git log —— 查看提交日志git log 命令可以查看以往的仓库中提交的日志。包括可以查看什么人在什么时候进行了提交合并，以及操作前后有怎样的差别。如果只想让程序显示第一行简述信息，可以使用 git log --pretty=short 。而只要在 git log 命令后面加上目录名或者文件名，即 git log xxx ，便会只显示该目录下的日志或该文件相关的日志。想查看提交所带来的改动，可以使用 git log -p ,文件的前后差别就会显示在提交信息之后。 git diff —— 查看更改前后的差别git diff 命令可以查看工作树、暂存区、最新提i叫之间的差别。 4.2 分支管理在进行多个并行作业时，我们会用到分支。在这类开发的过程中，往往同时存在多个最新的代码状态。不同的分支同时进行完全不同的作业，等当前分支的作业完成以后再与 master 分支合并。 说明：因为我们创建 Git 版本库时，Git 自动为我们创建了唯一一个 master 分支，所以，现在，git commit 就是往 master 分支上提交更改。 4.2.1 工作区和暂存区 工作区工作区可以理解为存放代码的目录。 版本库工作区有一个隐藏目录 .git，也就是Git的版本库。 暂存区Git的版本库里存了很多东西，其中最重要的就是称为 Stage（或者叫 Index）的暂存区。如下所示： 在前面，我们讲了我们把文件往 Git 版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 也就是说，首先是将工作区文件修改一个个添加（add）到暂存区（stage）中，然后将暂存区中的内容一次性提交到分支中（master）。 4.2.2 分支的操作 git branch —— 显示分支一览表git branch 命令可以将分支名列表显示，同时可以确认当前所在的分支，当前分支前面会标一个 * 号。 git checkout -b —— 创建、切换分支如果想以当前的 master 分支为基础创建新的分支，我们需要用到 git checkout -b 命令。例如，执行 git checkout -b branch-home ,就会创建名为 branch-home 的分支。而当我们想切换到 master 分支时，执行 git checkout master 就可以。在当前分支下切换到上一分支：git checkout - 。 git merge —— 合并分支假设我们完成了 branch-home 的工作，想要将它合并到主分支 master，首先，我们切换到 master 分支：git checkout master ，然后执行命令：git merge branch-home；如果想在历史记录中明确记录下本次分支合并，我们需要创建合并并提交，因此，在合并时加上 –no-ff 参数：git merge --no-ff branch-home 。 git branch -d —— 删除分支当我年将某一分支与主分支合并之后，就可以放心地删除这一分支了，执行：git branch -d branch-home 。 git log –graph —— 以图表形式查看分支用 git log –graph 命令进行查看的话，能很清楚、直观的看到分支提交的内容已经被合并。 4.2.3 更改提交的操作 git reset —— 回溯历史版本在使用 Git 的过程中，我们如果注意在一定的阶段就保存一次文件，给文件一个“快照”，这个快照就是 Git 中的 commit。这样，当我们在开发的过程中，一旦我们把文件弄乱了或者误删了文件，就可以从最近的一个 commit 恢复。假设我们误删了文件。需要恢复到最近的一个版本，首先我们需要用 git log 命令来查看文件更改的历史记录。例如： 需要注意的是：commit 后面的一大串数字：02a475d8330fea7…10dd3fb2f215b9d1882 是 commit id（版本号）。 这样，当我们想回退到某个版本时，只需要执行：git reset --hard HEAD 即可。其中，HEAD 表示当前版本，上一个版本就是 HEAD^，上上一个版本就是 HEAD^^，而 HEAD~100 表示往上100个版本。 git reset —— 回到未来版本当我们回退到某个版本后，我们后悔了，想重新回到之前的版本，应该怎么做呢？ git log 命令只能查看以当前状态为终点的历史日志。而使用 git reflog 命令，就可以查看当前仓库的操作日志，这个命令记录了你的每一次命令。通过查看仓库的操作日志，找出要恢复的那个版本的 commit id ，就可以恢复到之前的状态。 4.2.4 操作远程仓库前面 3.5.1 我们已经讲述过怎么添加远程仓库，即执行命令：git remote add origin https://github.com/JokeYang/Android_Bmob_Demo.git 以及 3.6 获取远程仓库，即执行命令：git clone。 git push —— 推送至远程仓库当我们想将当前分支下本地仓库中的内容推送给远程仓库时，需要执行 git push命令。例如，执行 git push -u origin master ,当前分支的内容就会被推送到远程仓库 origin 的 master 分支。-u 参数可以在推送的同时，将 origin 仓库的 master 分支设置为本地仓库当前分支的 upstream （上游）。同时，添加了这个参数，将来运行 git pull 命令从远程仓库获取内容是，本地仓库的这个分支就可以直接从 origin 的 master 分支获取内容。 git pull —— 获取最新的远程仓库分支除了 master 分支之外，远程仓库也可以创建其他分支。当我们想获取新的远程仓库分支时，就需要执行 git pull 命令，命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。 4.2.5 解决冲突在真实的 Git运行环境中，往往涉及多个用户对版本仓库的协作，而每个用户都有一个完整的 Git 版本仓库副本，所以在把各自的操作结果推送到远程仓库的时候出现冲突的可能性就非常高。冲突的类型有：逻辑冲突 、内容冲突 、树冲突 三种。解决这三种类型冲突的方法可以看这篇 博客。 4.3 其他操作 撤销修改使用 git checkout -- file 可以撤销修改。例如，git checkout -- readme.txt 就是把 readme.txt 文件在工作区的修改全部撤销。 删除文件使用 git rm 命令可以删除文件。如果你要从版本库中删除该文件，那就用命令 git rm 删掉，并且 git commit ，这样，文件就从版本库中被删除了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Axure 使用记]]></title>
      <url>%2F2016%2F12%2F12%2FAxure%20%E4%BD%BF%E7%94%A8%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[引言 记得有段时间想叛变投入产品门下，做一名产品狗。买了本 《Axure RP8网站和APP原型制作从入门到精通》 开始学习怎么使用 Axure来制作原型。好在之前做过 Android，所以上手比较快，几天下来，掌握了基本使用，但中继器和交互部分，还是做的不好。昨天在写博客时，有一部分文字叙述不是很好理解，就想着最好能有示例图。用 Visio 的话，有些地方达不到效果，而且自定义程度不是太理想。突然想到 Axure 似乎可以做到，于是就趁着机会再熟悉一下这个强大的软件工具。 首先，Axure 是一款专业的原型设计工具，可以设计出交互效果良好的产品原型，常用于互联网产品设计、网页设计、UI设计等领域。用它可以做出高交互的页面和动画效果。我，作为一个刚学习使用的菜鸟，就只能用来做做低保真原型、实现一些简单的交互以及做一些示例图。 1. 用 Axure 制作 APP 原型这是在学习用 Axure 制作原型时，自己做的一个图书馆 APP 的低保真原型，实现了部分简单的交互。 一、导航页导航页一： 导航页二： 二、注册登录登录注册主页： 登录页： 学号绑定页： 注册页2： 三、内容界面底部 Tab —— Home： 底部 Tab —— Search 底部 Tab —— Library 底部 Tab —— Find 底部 Tab —— Mine 四、APP 一些细节借阅管理： 这部分在设计时，考虑到用户会忘记自己已借阅书籍的时间，所以通过颜色 + 数字来醒目、直观的让用户获知到书籍的借阅时间。三种颜色分别表示：蓝色（在约定借阅时间内）、红色（即将到还阅时间）、橙色（借阅逾期）。 侧滑菜单 —— 索书收藏夹： 这个功能设计的目的是方便用户找书，在用户搜索到相关书籍之后，在书籍的详情页点击加入,就可以将当前图书的索书号及书本简略信息加入侧滑菜单的索书收藏夹。 阅读统计： 自从“淘宝时光机”的出现，这类基于用户数据分析的场景总能引起用户的关注，火遍朋友圈。所以，加入阅读统计，让用户可以分享自己的阅读数据，可以提升 APP 活跃度以及趣味性。 用户详情： 2. 用画示例图昨天试着用 Axure 画了几个示例图，发现挺好用的。 图一： 比如要说明 CSS 规范中的17种标准颜色，文字没有办法直观地展示。用 Axure 制作一个表格，然后在为各个表项添加内容，实现很简单。当然，使用 HTML＋CSS 也能达到这种效果，这部分我还不熟悉，以后有机会可以试试。 图二： 也可以根据自己的需要来制作。 图三： 当然，做表格什么的，也是没问题的，很简单。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS学习笔记（四）]]></title>
      <url>%2F2016%2F12%2F11%2FCSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
      <content type="text"><![CDATA[七、CSS核心知识7.1 CSS框模型CSS框模型（Box Model）规定了元素框处理元素内容、内边距、边距和外边距的方式。 由上面的图可以看出：元素框的最内部分是实际的内容，直接包围内容的是内边距。在CSS中，内边距呈现了元素的背景，其边缘是边框，而边框以外是外边距。外边距默认是透明的，因此不会遮挡其后的任何元素。一个元素的 宽度 是指内容框的宽度，而 高度 是指内容框的高度。下面解释两个重要的概念： 元素框：CSS假定每个元素都会生成一个或者多个矩形框，称为元素框。各个元素框中心有一个内容区域（contentarea）。这个内容区周围有可选的内边距、边框和外边距，因为，它们的宽度可以设置为0，即将这些项从元素框去除。 包含块：每个元素都相对于其包含块摆放。包含块简单的说就是一个参考框，作用是为它里面包含的元素提供一个参考。元素的尺寸和位置的计算往往是由该元素所在的包含块决定的。 对于某个元素来说，其真正所占的区域其实是由好几个矩形框组成，有：元素的内容框、补白形成的框、元素的边框以及边距形成的框。如下所示： 7.1.1 水平格式化和垂直格式化 水平属性——水平格式化的“7大属性”是：margin-left、border-left、padding-left、width、padding-right、border-right 和 margin-right。 说明：在水平属性中，只有3个属性可以设置为 auto：元素的 width 、左边距、右边距。其余的属性必须设置为特定的值，或者默认的宽度为0。 垂直属性——垂直格式化的“7大属性”是：margin-top、border-top、padding-top、height、padding-bottom、border-bottom 和 margin-bottom。 说明：在水平属性中，只有3个属性可以设置为 auto：元素的 height 、上边距、下边距。其余的属性必须设置为特定的值，或者默认的宽度为0。 7.1.2 内边距、边框、外边距1. 内边距CSS中的内边距是指元素边框与元素内容之间的空白区域，而这片区域由属性 padding 来控制。padding 属性接受长度值或百分比值，但不允许使用负值。1234567设置内边距的几种例子：1、 h1 &#123;padding: 10px;&#125; // h1 元素的各边都有 10 像素的内边距2、 h1 &#123;padding: 10px 0.25em 2ex 20%;&#125; //按照上、右、下、左的顺序分别设置各边的内边距，各边均可以使用不同的单位或百分比值3、 h1 &#123; padding-top: 10px; padding-right: 0.25em; padding-bottom: 2ex; padding-left: 20%;&#125; //通过四个单独的属性，分别设置上、右、下、左内边距 2. 边框CSS中的边框是指围绕元素内容和内边距的一条或多条线。在CSS中，可以通过 border 属性来设置元素边框的样式、宽度和颜色。 边框的样式：CSS 的 border-style 属性定义了 10 个不同的非 inherit 样式，包括 none。如果希望显示某种边框，就必须设置边框样式。 1234border-style: [ none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset ]&#123;1,4&#125; | inherit在实际的应用中，我们可以为一个边框设置多个样式，也可以为元素框的某一边设置边框样式。例如：1、 p.aside &#123;border-style: solid dotted dashed double;&#125;2、 p &#123;border-style: solid; border-left-style: none;&#125; 边框的宽度：可以通过 border-width 属性为边框指定宽度。为边框指定宽度有两种方法：可以指定长度值，比如 2px 或 0.1em；或者使用 3 个关键字之一，它们分别是 thin 、medium（默认值） 和 thick。 12345678border-width: thin | medium | thick | &lt;length&gt; | inherit在实际的应用中,可以一次性的指定各边边框的宽度，也可以分别设置边框各边的宽度。例如：1、 p &#123; border-style: solid; border-width: 5px;&#125;2、 p &#123; border-style: solid; border-top-width: 15px; border-right-width: 5px; border-bottom-width: 15px; border-left-width: 5px;&#125; 边框的颜色：使用 border-color 属性，它一次可以接受最多 4 个颜色值。 1234567border-color: [ &lt;color&gt; | transparent ]&#123;1,4&#125; | inherit同样的，可以一次性的指定各边边框的颜色，也可以分别设置边框各边的颜色。例如：1、 p &#123; border-style: solid; border-color: blue red;&#125;2、 h1 &#123; border-style: solid; border-color: black; border-right-color: red;&#125; 3. 外边距CSS中的外边距是指围绕在元素边框的空白区域。CSS中，外边距使用通过 margin 属性设置。margin 属性接受任何长度单位，可以是像素、英寸、毫米或 em 等。1234567设置外边距的几种例子：1、 h1 &#123; margin: 10px;&#125; // h1 元素的各边都有 10 像素的外边距2、 h1 &#123; margin: 10px 0.25em 2ex 20%;&#125; //按照上、右、下、左的顺序分别设置各边的外边距，各边均可以使用不同的单位或百分比值3、 h1 &#123; margin: 10px; margin-right: 0.25em; margin: 2ex; margin: 20%;&#125; //通过四个单独的属性，分别设置上、右、下、左外边距 提示：Netscape 和 IE 对 body 标签定义的默认边距（margin）值是 8px。而 Opera 不是这样。相反地，Opera 将内部填充（padding）的默认值定义为 8px，因此如果希望对整个网站的边缘部分进行调整，并将之正确显示于 Opera 中，那么必须对 body 的 padding 进行自定义。 4. 外边距合并外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。 情形一：当一个元素出现在另一个元素上面时，第一个元素的下外边距与第二个元素的上外边距会发生合并。如下图所示： 情形二：当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生合并。如下图所示： 情形三：外边距甚至可以与自身发生合并，比如，有一个空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并，如下图所示： 情形四：如果这个外边距遇到另一个元素的外边距，它也会发生合并： 注意：只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。 5. 值复制什么是值复制呢？举个例子，有时，我们会输入一些重复的值，比如：1p &#123;margin: 0.5em 1em 0.5em 1em;&#125; 通过值复制，不再需要像这样重复的键入这对数字。上面的规则也可以写作这样：1p &#123;margin: 0.5em 1em;&#125; 这两个值可以取代前面 4 个值。这是如何做到的呢？CSS 定义了一些规则，允许为外边距指定少于 4 个值。规则如下： 如果缺少左外边距的值，则使用右外边距的值。 如果缺少下外边距的值，则使用上外边距的值。 如果缺少右外边距的值，则使用上外边距的值。 下面的图片提供了更直观的方法来说明这一规则： 7.2 CSS布局CSS包含3种基本的布局模型，即流动模型（Flow）、浮动模型（Float）、层模型（Layer）。 7.2.1 流动模型（Flow）流动（Flow）是默认的网页布局模式，网页在默认状态下的 HTML 网页元素都是根据流动模型来分布网页内容的。流动布局模型具有2个比较典型的特征： 块状元素 都会在所处的包含元素内自上而下按顺序垂直延伸分布，独占一行,在默认状态下，块状元素的宽度都为100%。 内联元素 都会在所处的包含元素内从左到右水平分布显示。 7.2.2 浮动模型（Float）在 流动模型（Flow） 中，所谓的标准流是指从上到下，从左到右，输出文档内容。所以，在流动模型下，块级元素由于其独占一行的特点，即使在某一行能够同时容下两个块级元素的情况下，两个块级元素还是会自上而下按顺序垂直延伸分布。而 浮动模型（Float），则可以实现在一行放置多个块级元素。 1. 浮动（float）浮动可以理解为将浮动元素从标准流中删除，即元素将脱离标准文档流，浮动元素将不在页面占用空间，浮动于标准流之上，和标准流不在一个层次。在CSS中，所有元素都可以浮动，可以使用属性 float 实现。1float: left | right | none | inherit 关于浮动元素的摆放，有着以下一些特定的规则： 浮动元素的左（或右）外边界不能超出其包含块的左（或右）内边界。也就是说：浮动的框可以向左或向右移动，直到它的外边缘碰到包含框。 浮动元素的左（或右）外边界必须是源文档中之前出现的左浮动（或右浮动）元素的右（或左）边界，除非后出现浮动元素的顶端出现在先出现浮动元素的底端下面。也就是说：除了包含框，浮动的框在向左或向右移动时，碰到另一个浮动框的边框时也会停止移动。 左浮动元素的右外边界不会在其右边右浮动元素的左外边界的右边。一个右浮动元素的左外边界不会在其左边任何左浮动元素的右外边界的左边。也就是说：当某一行无法同时容纳一个向左、一个向右的浮动元素时，其中顺序在后面的那个浮动元素将向下浮动，直到它的顶端在顺序在前的那个浮动元素的底端之下。 一个浮动元素的顶端不能比其父元素的内顶端更高。如果一个浮动元素在两个合并外边距之间，放置这个浮动元素时就好像在两个元素之间有一个块级父元素。 浮动元素的顶端不能比之前所有浮动元素或块级元素的顶端更高。 如果源文档中一个浮动元素之前出现另一个元素，浮动元素的顶端不能比包含该元素所生成框的任何行框的顶端更高。 左（或右）浮动元素的左边（右边）有另外一个浮动元素，前者的右外边界不能在其包含块的右（左）边界的右边（左边）。 浮动元素必须尽可能高地放置。 左浮动元素必须向左尽可能远，右浮动元素则必须向右尽可能远。位置越高，就会向右或向左浮动的越远。 注意：浮动元素会延伸，从而包含其所有后代浮动元素。所以，通过将父元素设置为浮动元素，就可以把浮动元素包含在其父元素内。 如果一个浮动元素与正常流中的内容发生重叠会怎么样呢？在CSS2.1中，针对以上问题，有着以下的规则： 行内框与一个浮动元素重叠时，其边框、背景和内容都在该浮动元素“之上”显示。 块框与一个浮动元素重叠时，其边框和背景在该浮动元素“之下”显示，而内容在浮动元素“之上”显示。 2. 清除（clear）针对正常流与浮动流重叠的问题，CSS中，可以使用属性 clear 的设置来禁止浮动元素与某个元素在同一行上。clear 属性的值可以是 left、right、both 或 none，它表示框的哪些边不应该挨着浮动框。1clear: left | right | both | none | inherit 7.2.3 层模型（Layer）所谓的层模型，就是CSS中，可以通过属性 position 来对元素进行精确的定位。层模型有三种形式（CSS的三种定位机制）： 绝对定位（position:absolute） 相对定位（position:relative） 固定定位（position:fixed） 1. 定位通过定位，可以准确地定义元素框相对于其正常位置应该出现在哪里，或者相对于父元素、另外一个元素甚至浏览器窗口本身的位置。通过使用 position 属性，会影响元素框生成的方式。CSS中可以选择 4 种不同类型的定位： static：元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框，置于其父元素中。 relative：元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留。 absolute：元素框从文档流完全删除，并相对于其包含块定位。包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。 fixed：元素框的表现类似于将 position 设置为 absolute，不过其包含块是视窗本身。 定位中的一些基本概念： 一、偏移属性 CSS的三种定位机制（relative、absolute 和 fixed）使用4个属性来米搜狐定位元素各边相对于其包含块的偏移，这4个属性称为偏移属性。12偏移属性（top、right、bottom、left）值: &lt;length&gt; | &lt;percentage&gt; | auto | inherit 二、内容溢出和裁剪 溢出（overflow）：假设在某种情况下，一个元素固定为某个特定大小，但内容在元素中放不下。此时就可以利用 overflow 属性控制这种情况。 1overflow: visible | hidden | scroll | auto | inherit 裁剪（clip）：如果一个绝对定位元素的内容溢出其内容框，而且 overflow 设置为要求裁剪该内容，通过使用属性 clip 可以改变裁剪区域的形状。 1clip: rect(top,right,bottom,left) | auto | inherit 元素可见性（visibility）：通过属性 visibility 可以控制整个元素的可见性。 1visibility: visible | hidden | collapse | inherit 2. 相对定位为元素设置层模型中的相对定位，需要设置 position: relative（表示相对定位），它通过偏移属性 left、right、top、bottom 确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按 static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动，移动的方向和幅度由 left、right、top、bottom 属性确定，元素仍然保持其未定位前的形状，它原本所占的空间仍保留。也就是说，如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。 说明： 相对定位实际上被看作普通流定位模型的一部分，因为元素的位置相对于它在普通流中的位置。 在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 3. 绝对定位为元素设置层模型中的绝对定位，需要设置 position: absolute（表示绝对定位），设置为绝对定位的元素框会从文档流完全删除，然后使用偏移属性 left、right、top、bottom 相对于其包含块定位。包含块可能是文档中的另一个元素或者是初始包含块。 说明： 对于进行绝对定位的元素来说，元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。也就是说，绝对定位使元素的位置与文档流无关，因此不占据空间。这一点与相对定位不同，相对定位实际上被看作普通流定位模型的一部分，因为元素的位置相对于它在普通流中的位置。 绝对定位的元素的位置相对于 最近的已定位祖先元素，如果元素没有已定位的祖先元素，那么它的位置相对于 最初的包含块。而根据用户代理的不同，最初的包含块可能是画布或 HTML 元素。 相对定位和绝对定位的 区别：相对定位是“相对于”元素在文档中的初始位置，而绝对定位是“相对于”最近的已定位祖先元素，如果不存在已定位的祖先元素，那么“相对于”最初的包含块。 补充：因为绝对定位的框与文档流无关，所以它们可以覆盖页面上的其它元素。CSS中，可以通过设置 z-index 属性（z-index: &lt;integer&gt; | auto | inherit）来控制这些框的堆放次序。例如,分别为 id 是first 和 second 的 p 元素设置 z-index，如下所示:12p#first &#123;position: absolute; top: 0; left: 0; width :20%; height: 10em; z-index: 8;&#125;p#second &#123;position: absolute; top: 0; left: 10%; width :30%; height: 5em; z-index: 4;&#125; //由于 first 相对于 second 的 z-index 值较高，则其在 second 之上。 4. 固定定位固定定位，与 absolute 定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化。除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小。因此，固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响，这与 background-attachment: fixed 属性功能相同。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS学习笔记（三）]]></title>
      <url>%2F2016%2F12%2F08%2FCSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
      <content type="text"><![CDATA[四、CSS的特殊性、继承和层叠CSS的特殊性（也称优先级）、继承和层叠通常被称为CSS的三大特性。 4.1 特殊性CSS的特殊性解决的是当我们对同一个元素设置了不同的 CSS 样式，那么到底最后作用于元素是哪个样式呢？例如下面的规则：12345h1 &#123;color: red;&#125;body h1 &#123;color: green;&#125;h2.grape &#123;color: purple;&#125;h2 &#123;color: silver;&#125; 最终，元素 h1 显示的是 green，而 h2 显示的是 purple。原因在于每个选择器都有它的特殊性。对于每个规则，用户代理(浏览器)会计算选择器的特殊性(权值)，这样规则中选择器对应的声明就有了相应的特殊性(权值)。当有两个或者多个属性声明作用于一个元素时，就可以根据这个特殊性(权值)来决定哪条声明奏效，特殊性(权值)越高，则相应的声明就会被应用。 选择器的特殊性是由选择器本决定的。选择器的具体特殊性(权值)，如下： ID选择器的特殊性(权值)为：0，1，0，0 类选择器、属性选择器或者伪类的特殊性(权值)为：0，0，1，0 元素或者伪元素的特殊性(权值)为：0，0，0，1 结合符和通配符没有特殊性(权值) 注意：内联样式的特殊性(权值)为：1，0，0，0 计算一个组合选择器的特殊性(权值)的时候，在计算不同选择器的数量以及其对应的特殊性(权值)后再相加，例如：12345678910div ul li &#123;color:red;&#125; /* 0,0,0,3 3个元素选择器 */div.nav ol li &#123;color:purple;&#125; /* 0,0,1,3 1个类选择器，3个元素选择器 */a:hover &#123;color:blue;&#125; /* 0,0,1,1 1个伪类选择器，1个元素选择器 */div.navlinks a:hover &#123;color:yellow;&#125; /* 0,0,2,2 1个类选择器，1个伪类选择器，2个元素选择器 */.affix.top&#123;background:silver&#125; /* 0,0,2,0 多类选择器 注 */input[type="text"] &#123;font-style:italic;&#125; /* 0,0,1,1 1个属性选择器，1个元素选择器 */input[name="sex"][type="radio"] &#123;background:silver;&#125; /* 0,0,2,1 2个属性选择器，1个元素选择器 */#title em &#123;font-weight:12px;&#125; /* 0,1,0,1 1个 ID 选择器，1个元素选择器 */h1#title em &#123;font-weight:14px;&#125; /* 0,1,0,2 1个 ID 选择器，2个元素选择器 */* &#123;background:silver;&#125; /* 0,0,0,0 1个通用选择器 */ 4.2 继承CSS的某些样式是具有继承性的，那么继承到底是什么意思呢？CSS中，继承是一种规则，它允许样式不仅应用于某个指定的元素，而且应用于其后代元素。例如,应用了下面CSS样式的h1元素：1h1 &#123;color: gray;&#125; 1&lt;h1&gt;Welcome to &lt;em&gt;NanJing&lt;/em&gt;&lt;/h1&gt; h1元素应用了一个颜色，那么，这个颜色将应用到h1中的所有文本，甚至应用到h1元素的子元素中的文本。 注意： CSS的某些样式是具有继承性的。在CSS中，大多数框模型属性(包括外边距、内边距、背景和边框)都不能被继承。如果可以继承，那么，文档将会变得混乱不堪。 在CSS的特殊性规则中，继承的声明根本没有任何特殊性，而使用通配选择器的声明具有0, 0, 0, 0特殊性。当二者冲突时，通配选择器胜，会导致继承失效。正因为如此，一般不建议使用 (*)。例如：12* &#123;color: red;&#125;h1 &#123;color: gray;&#125; 123456789101112&lt;h1&gt;Welcome to &lt;em&gt;NanJing&lt;/em&gt;&lt;/h1&gt;``` 最后的结果如下图所示： ![短路继承](http://ogcpvdyqb.bkt.clouddn.com/%E7%BB%A7%E6%89%BF%E7%9F%AD%E8%B7%AF.png)### 4.3 层叠CSS中，层叠解决的是这样一个问题：如果特殊性相等的两个规则同时应用到同一个元素，到底哪个规则会被应用呢？例如，以下的规则：```CSSh1 &#123;color: red;&#125;h1 &#123;color: blue;&#125; 4.3.1 层叠规则CSS中所谓的层叠，就是让多个来源的样式叠加在一起，然后结合样式的特殊性、继承性，确定最终应用的样式。在《CSS权威指南》这本书中指出，确定最终应用的样式，CSS2.1有4条层叠规则： 找出所有相关的规则，这些规则都包含与一个给定元素匹配的选择器。 按显示权重对应用到该元素的所有声明排序。标志!important的规则的权重要高于没有!important标志的规则。按来源对应用到给定元素的所有声明进行排序。共有3种来源：创作人员、读者和用户代理。正常情况下，创作人员的样式要胜过读者的样式。有!important标志的的读者样式要强于所有其他样式，包括有!important标志的创作人员样式。创作人员的样式和读者样式斗都比用户代理的默认样式强。 按特殊性对应用到给定元素的所有声明进行排序，有较高特殊性的元素权重要大于有较低特殊性的元素。 按出现顺序对应用到给定元素的所有声明排序。一个声明在样式表或文档中越后出现，它权重就越大。如果样式表中有导入的样式表，一般认为出现在导入样式表中的声明在前，主样式表中的所有声明在后。 简单的来说，上述的规则意思是：对于一个指定的元素，将应用于该元素的所有规则，先按规则的显式权重和来源进行排序。如果相同，则比较规则的特殊性。若特殊性也相同，则比较规则的顺序。 4.3.2 层叠总结一、按权重和来源排序 在《CSS权威指南》中，样式的来源可以分为3类：1、创作人员 ( 即内联式样式、嵌入式样式、外部式样式 ); 2、读者 ( 即用户自定义样式 ); 3、用户代理 ( 即浏览器样式 )。 按照上述分类的样式，权重由大到小的顺序依次为： 读者的重要声明 创作人员的重要声明 创作人员的正常声明 读者的正常声明 用户代理声明 按照上述分类的样式，根据来源的排序为： 创作人员（内联式样式、嵌入式样式、外部式样式） 读者（用户自定义样式） 用户代理（浏览器样式） 二、按特殊性排序 如果一个元素应用了多个彼此冲突的声明，而且他们的权重声明相同，则按照特殊性排序，特殊性值（权值）高的被应用。 三、按顺序排序 如果两个规则的权重、来源和特殊性完全相同，那么，在样式表中后出现的一个会被应用。 注意：由于内联式样式表的特殊性，CSS中有推荐的链接样式顺序。一般建议按link-visited-hover-active（LVHA）的顺序声明连接样式。如下所示：1234:link &#123;color: blue;&#125;:visited &#123;color: purple;&#125;:hover &#123;color: red;&#125;:active &#123;color: orange;&#125; 五. CSS中的单位、颜色、字体、文本5.1 CSS中的单位CSS中的单位有：%（百分数）、in（英寸）、cm（厘米）、mm（毫米）、pt（点）、pc（派卡）、em（1em等于等于当前字体的尺寸）、ex（1ex是一个字体的x-height,而x-height通常是字体尺寸的一半）、px（像素，即计算机屏幕上的一个点）。 总结： 在《CSS权威指南》中，in（英寸）、cm（厘米）、mm（毫米）、pt（点）、pc（派卡）被称为绝对长度单位。在 Web 设计中，几乎很少使用绝对长度单位。 在《CSS权威指南》中，em（1em等于等于当前字体的尺寸）、ex（1ex是一个字体的x-height,而x-height通常是字体尺寸的一半）、px（像素，即计算机屏幕上的一个点）被称为相对长度单位。 5.2 CSS中的颜色在CSS中，颜色有前景和背景色，可以为任何元素设置。CSS中，关于颜色的表示有4种方式：颜色名、RGB、16进制、HSL（CSS3）。 说明：1一般来说，前景是元素的文本，不过前景还包括元素周围的边框。 5.2.1 用颜色名表示颜色在CSS 2.1 中，CSS规范定义了17个标准颜色名。包括HTML 4.01中定义的16个颜色，并外加一个橙色：123aqua fuchsia lime olive red whiteblack gray maroon silver yellow bluegreen navy purple teal orange 5.2.2 用RGB表示颜色RGB颜色即计算机通过组合不同的红色、绿色和蓝色分量来创造颜色。使用RGB来表示颜色，有两种表示方法：百分数记法、整数三元组记法。例如，用RGB来表示白色：12rgb(100%,100%,100%) 百分数记法rgb(255,255,255) 整数三元组记法 5.2.3 用16进制表示颜色16进制记法，即将三个介于00-FF的16进制数连起来表示一种颜色。例如，白色用16进制来表示是：1#FFFFFF 5.2.4 用HSL表示颜色HSL是不同于RGB的色彩模式，HSL分别表示色调、饱和度、亮度，通过这三个参数来表示不同颜色。其中： H(Hue色调)：表示一个色相环，从0到360度取值，0(或360)是红色，120是绿色，240是蓝色； S(Saturation饱和度)：表示颜色的纯度，取值从 0.0% 到 100.0%，数值越大，颜色中的灰色越少，颜色越接近纯色；L(Lightness亮度)：表示颜色的明暗，取值也是 0.0%——100.0%，0%是彻底变暗（黑），100%彻底变亮（白），50%正常亮度。 5.3 CSS中的URL、关键字5.3.1 URLCSS中，URL用来引用一个资源，这个资源可以是图片、样式表。URL有绝对URL和相对URL之分： 绝对URL 12绝对URL的格式一般是：url(protocol://server/pathname)例如：url(http://ogcpvdyqb.bkt.clouddn.com/color.png) 相对URL 12相对URL的格式一般是：url(pathname)例如：url(color.png) 说明： 使用相对URL，则说明引用资源的页面和资源在同一个服务器上。 5.3.2 关键字关键字：用来描述某个属性的值的词。例如，常见的 none、normal 等。 关键字-inherit：在CSS2.1中，inherit 关键字是所有属性共有的。inherit 使一个属性的值与其父元素的值相同。 5.4 CSS中的字体CSS 字体属性定义文本的字体系列、大小、加粗、风格（如斜体）和变形（如小型大写字母）。在CSS中，有两种不同类型的字体类型：特定字体系列、通用字体系列。 特定字体系列：如 Times、Verdana、Helvetica或Arial等； 通用字体系列：CSS 定义了5种通用字体，Serif 字体、Sans-serif 字体、Monospace 字体、Cursive 字体、Fantasy 字体； 5.4.1 字体系列的使用在CSS中，可以使用属性 font-family 来定义文本的字体系列。 给元素指定通用字体系列，例如：1body &#123;font-family: sans-serif;&#125; 说明：所谓字体系列，是因为 sans-serif 包含多个字体，这些字体组成一个系列。当指定 sans-serif 系列字体，用户代理（浏览器）会根据用户端实际拥有的字体来进行适配。例如用户端实际安装了 Helvetica 字体，body 元素就会应用 Helvetica 字体。 给元素指定字体，例如：1h1 &#123;font-family: Georgia;&#125; 除了使用通用的字体系列，还可以通过 font-family 属性设置更具体的字体。但相应的，这样设置指定的字体的同时会产生另外一个问题，如果用户代理上没有安装 Georgia 字体，就只能使用用户代理的默认字体来显示 h1 元素。所以，强烈建议在所有 font-family 规则中都提供一个通用字体系列，这样在用户代理无法提供与规则匹配的特定字体时，就可以选择一个候选字体。例如：123h1 &#123;font-family: Georgia, serif;&#125;h2 &#123;font-family: Times, TimesNR, 'New Century Schoolbook', Georgia, 'New York', serif;&#125; 如果用户没有安装 Georgia 字体，但安装了 Times 字体（serif 字体系列中的一种字体），用户代理就可能对 h1 元素使用 Times。尽管 Times 与 Georgia 并不完全匹配，但至少足够接近。 注意： 当字体名中有一个或者多个空格（如 New York），或者这些字体名包括 # 或 $ 之类的符号，使用 font-family 属性时，需要在声明中加引号。 5.4.2 字体的其它属性除了指定字体系列，常用的字体属性还有：字体的加粗（font-weight）、字体的大小（font-size）、字体的风格（font-style）、字体的变形（font-variant）、字体的拉伸（font-stretch）、字体的调整（font-size-adjust）。 字体加粗（font-weight）： 1font-weight: normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | inherit 字体的大小（font-size）： 1font-size: xx-small | x=small | small | medium | larage | x-large | xx-large | smaller | larager | &lt;length&gt; | &lt;percentage&gt; | inherit 字体的风格（font-style）： 1font-style: italic | oblique | normal | inherit 字体的变形（font-variant）： 1font-variant: small-caps | normal | inherit 字体的拉伸（font-stretch）： 1font-stretch: normal | wider | narrower | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | inherit 字体的调整（font-size-adjust）： 1font-size-adjust: &lt;number&gt; | none | inherit font 属性：这是一个简写属性，作用是把所有针对字体的属性设置在一个声明中。 1font: [[&lt;font-style&gt; || &lt;font-variant&gt; || &lt;font-weight&gt;]?&lt;font-size&gt;[/&lt;line-height&gt;]?&lt;font-family&gt;] | caption | icon | menu | message-box | small-caption | status-bar | inherit 例如：1h1 &#123;font:italic bold 12px/30px arial,sans-serif;&#125; 5.5 CSS中的文本属性文本属性可定义文本的外观。通过文本属性，您可以改变文本的颜色、字符间距，对齐文本，装饰文本，对文本进行缩进，等等。CSS中，文本属性有：缩进文本（text-indent）、水平文本对齐（text-align）、行高（line-height）、垂直对齐文本（vertical-align）、字间隔（word-spacing）、字母间隔（letter-spacing）、文本转换（text-transform）、文本装饰（text-decoration）、文本阴影（text-shadow）、处理空白格（white-space）、文本方向（direction）或者（unicode-bidi）。 缩进文本（text-indent） 1text-indent: &lt;length&gt; | &lt;percentage&gt; | inherit 水平对齐（text-align） 12CSS2.1 text-align: left | center | right | justify | inheritCSS2 text-align: left | center | right | justify | &lt;string&gt; | inherit 行高（line-height） 1line-height: &lt;length&gt; | &lt;percentage&gt; | &lt;number&gt; | normal | inherit 垂直对齐文本（vertical-align） 1vertical-align: baseline | sub | super | text-top | text-bottom | middle | top | bottom | &lt;percentage&gt; | &lt;length&gt; 字间隔（word-spacing） 1word-spacing: &lt;length&gt; | normal | inherit 字母间隔（letter-spacing） 1letter-spacing: &lt;length&gt; | normal | inherit 文本转换（text-transform） 1text-transform: uppercase | lowercase | capitalize | none | inherit 文本装饰（text-decoration） 1text-decoration: none | [underline || overline || line-through || blink] | inherit 文本阴影（text-shadow） 1234text-shadow: none | [&lt;color&gt; || &lt;length&gt;&lt;length&gt;&lt;length&gt;?,]* [&lt;color&gt; || &lt;length&gt;&lt;length&gt;&lt;length&gt;?] | inherit例如：h1 &#123;text-shadow: yellow 2px 2px 2px;&#125;p &#123;text-shadow: 0 0 4px silver;&#125; 处理空白格（white-space） 1white-space: normal | pre | nowrap | pre-wrap | pre-line 文本方向（direction） 1direction: ltr | rtl | inherit 文本方向（unicode-bidi） 1unicode-bidi: normal | embed | bidi-override | inherit 说明：对于行内元素，只有当 unicode-bidi 属性设置为 embed 或 bidi-override 时才会应用 direction 属性。direction 属性有两个值：ltr 和 rtl。大多数情况下，默认值是 ltr，显示从左到右的文本。如果显示从右到左的文本，应使用值 rtl。 六. CSS中的背景、表格、列表、生成内容与轮廓6.1 背景元素的背景是指前景之下直到边框外边界的所有空间，内容框和内边距都是元素背景的一部分，并且边框画在背景之上。 背景色（background-color）：这个属性接受任何合法的颜色值，默认值是 transparent（透明）。 1background-color: &lt;color&gt; | transparent | inherit 背景图像（background-image）：这个属性允许向任何元素应用背景图像，默认值是 none。 1background-image: &lt;uri&gt; | none | inherit 背景重复（background-repeat） 1background-repeat: repeat | repeat-x | repeat-y | no-repeat | inherit 背景定位（background-position） 123background-position: [[&lt;percentage&gt; | &lt;length&gt; | left | center | right][&lt;percentage&gt;] | &lt;length&gt; | top | center | bottom]?] || [[left | center | right] || [top | center | bottom]] | inherit例如：p &#123;background-image: url(logo.gif);background-repeat: no-repeat;background-position: top right;&#125; 背景关联（background-attachment）：如果文档比较长，那么当文档向下滚动时，背景图像也会随之滚动。当文档滚动到超过图像的位置时，图像就会消失。通过背景关联这个属性，可以防止这种滚动。默认值是 scroll（滚动）。 1background-attachment: scroll | fixed | inherit 6.2 表格 设置表标题 1caption-side: top | bottom 设置表单元格边框 1border-collapse: collapse | separate | inherit 设置边框间隔 1border-spacing: &lt;length&gt;&lt;length&gt;? | inherit 处理空单元格 1empty-cells: show | hide | inherit 设置表大小 1table-layout: auto | fixed | inherit 6.3 列表 列表类型：要影响列表的样式，最简单（同时支持最充分）的办法就是改变其标志类型。要修改用于列表项的标志类型，可以使用属性 list-style-type： 12CSS2.1 list-style-type：disc | circle | square | decimal | decimal-leading-zero | lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | none | inheritCSS2 list-style-type：disc | circle | square | decimal | decimal-leading-zero | upper-alpha | lower-alpha | upper-roman | lower-roman | lower-greek | hebrew | armenian | georgian | cjk-ideographic | hiragana | katakana | hiragana-iroha | none | inherit 列表项图像：使用 list-style-image 属性可以为列表项设置一个图像标志。 1list-style-image: &lt;uri&gt; | none | inherit 列表标志位置：CSS2.1 可以通过属性 list-style-position 确定标志出现在列表项内容之外还是内容内部。 1list-style-position: inside | outside | inherit 简写列表样式：为简单起见，可以将以上 3 个列表样式属性合并为一个方便的属性：list-style。 1[&lt;list-style-type&gt; || &lt;list-style-image&gt; || &lt;list-style-position&gt;] | inherit 6.4 生成内容在CSS2 和 CSS 2.1 中，生成内容是指由浏览器创建的内容。例如，列表标志就是生成内容。为了向文档中插入生成内容，可以使用 :before 和 :after 伪元素结合 content 属性来生成内容。1content: normal | [&lt;string&gt; | &lt;uri&gt; | &lt;counter&gt; | attr(&lt;identifier&gt;) | open-quote | close-quote | no-open-quote | no-close-quote]+ | inherit content 的内容一般可以为以下四种： none： 不生成任何值； attr： 插入标签属性值； url： 使用指定的绝对或相对地址插入一个外部资源（图像，声频，视频或浏览器支持的其他任何资源）； string： 插入字符串。 补充： 引号：使用 quotes 可以为不同的内容加上合适的引号。1quotes: [&lt;string&gt; &lt;string&gt;]+ | none | inherit 计数器：使用计数器可以创建包含数字序号的内容。1234重置（counter-reset）：设置计数器的起点。counter-reset: [&lt;indentifier&gt;&lt;integer&gt;?]+ | none | inherit递增（counter-increment）：设置可以递增的计数器。counter-increment: [&lt;indentifier&gt;&lt;integer&gt;?]+ | none | inherit 6.5 轮廓轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。 设置轮廓样式 1outline-style: none | dotted | dashed | solid | double | groove | ridge | inset | outset | inherit 设置轮廓宽度 1outline-width: thin | medium | thick | &lt;length&gt; | inherit 设置轮廓颜色 1outline-color: &lt;color&gt; | invert | inherit]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS学习笔记（二）]]></title>
      <url>%2F2016%2F12%2F06%2FCSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[三、 CSS选择器在CSS语法部分，我们已经了解CSS规则由 选择器 和 声明 组成。如下所示：123选择器 &#123; 声明 ；&#125; 选择器 就是{ }之前的部分，它指明了{ }中的声明的作用对象，也就是声明作用于网页中的哪些元素。在CSS（主要是CSS2、CSS2.1，部分CSS3）中，选择器主要有以下： 元素选择器 、通配选择器 、类选择器 、ID选择器 、多类选择器 、属性选择器 、派生选择器 、伪类选择器 、伪元素选择器。 3.1 元素选择器最常见的 CSS 选择器是元素选择器。换句话说，文档的元素就是最基本的选择器。如果设置 HTML 的样式，选择器通常将是某个 HTML 元素，比如 p、h1、em、a，甚至可以是 html 本身：123html &#123;color: black;&#125;h1 &#123;color: gray;&#125;h2 &#123;color: silver;&#125; 说明：关于 元素选择器 和 标签选择器 ，这两个概念其实是一样的。在《CSS权威指南》这本书中讲到选择器时提到的是 “元素选择器” ；而在其他的资料中，讲到选择器，提到的是 “标签选择器” 。这是因为，CSS 依赖于元素，规则作用于元素，所以 CSS 中习惯称为 “元素选择器” 。而 CSS 样式作用的元素通常就是 HTML 文档的标签，所以，”元素选择器” 也常被称为 “标签选择器” 。 3.2 通配选择器CSS2引入了一种新的简单的选择器，叫做通配选择器，显示为一个星号 (&lowast;) 。通配选择器可以与任何元素匹配，就像是一个通配符，通配选择器后的声明将应用于文档中的所有元素。例如，下面的这条规则是将文档中的每一个元素都设置为红色：1* &#123;color: red;&#125; 注意：考虑到通配选择器的特殊性，在使用的时候，我们要小心。 3.3 类选择器区别与元素选择器，类选择器的使用不需要考虑具体涉及的元素，使用的时候只需要为那些要应用样式的元素的class属性指定一个恰当的值，这样，这些元素就会被归类到一起，之后要做的，就是为这些归类的元素应用样式。其语法是 .类选择器名称 {CSS代码;} ，如下所示,是为所有类名为 important 的元素设置了字体为红色、加粗：1234.important &#123; color: red; font-weight: bold;&#125; 上面的写法是常用的书写方式，类选择器忽略了通配选择器，完整的写法应该是：1234*.important &#123; color: red; font-weight: bold;&#125; 例如，如果有以下的元素，其class属性指定为important，那么，他们都会应用上述的CSS样式。1234567891011121314151617&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;类选择器示例&lt;/title&gt;&lt;style type="text/css"&gt;.important &#123; color:red; font-weight: bold;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 class="important"&gt;通知&lt;/h1&gt; &lt;p&gt;紧急通知，&lt;span class="important"&gt;今天下午三点&lt;/span&gt;，在&lt;span class="important"&gt;南操场&lt;/span&gt;举行消防演练。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 3.4 多类选择器类选择器应用于元素的class属性值为单个词的情况，而在HTML中，元素的class值可能会被设定为多个词组成的一个词列表，每个词之间用空格分隔。例如，如果希望将一个特定的元素同时标记为重要（important）和强调（stress），就可以写作：123&lt;p class="important stress"&gt; This paragraph is a very important stress.&lt;/p&gt; 提示：需要注意的是，这两个词：重要（important）和强调（stress）的顺序无关紧要，写成 stress important 也可以。 下面我们举个例子来详细的说明多类选择器的使用：假设class属性为important的类，其所有的元素都是红色、粗体；而class属性为warning的类，其所有的元素都是斜体、下划线；class属性同时设置为important和warning的类，其背景为银色。具体的表现如下所示：12345678910111213141516171819202122232425&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;多类选择器示例&lt;/title&gt;&lt;style type="text/css"&gt;.important &#123; color:red; font-weight: bold;&#125;.stress &#123; font-style: italic; text-decoration: underline;&#125;.important.stress &#123; background: silver;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 class="important stress"&gt;勇气&lt;/h1&gt; &lt;p&gt;三年级时，我还是一个&lt;span class="important"&gt;胆小如鼠&lt;/span&gt;的小女孩，上课从来不敢回答老师提出的问题，生怕回答错了老师会批评我。就一直没有这个勇气来回答老师提出的问题。学校举办的活动我也没勇气参加。&lt;/p&gt; &lt;p&gt;到了三年级下学期时，我们班上了一节公开课，老师提出了&lt;span class="stress"&gt;一个很简单的问题，班里很多同学都举手了，甚至成绩比我差很多的，也举手了，还说着："我来，我来。"&lt;/span&gt; 我环顾了四周，就我没有举手。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 提示：通过把两个类选择器链接在一起，仅可以应用到同时包含这些类名的元素（类名的顺序不限）。 也就是说，如上面的代码中那样，将important和stress两个选择器链接在一起，形成多类选择器 .important.stress {background: silver;} ，则只有某个元素的class属性的值 同时 包含important和stress时，多类选择器中的样式才会被应用。 注意： 如果一个多类选择器包含类名列表中没有的一个类名，匹配就会失败。就像下面的这种情况：123p.important.stress &#123; background: silver;&#125; 上面的选择器将只匹配class属性同时包含 important 和 stress 的那些p元素。因此，如果一个p元素的 class 属性是 important 和 warning，将不能匹配。 匹配的条件 同时包含 是指多类选择器中的多个类要被某一个要应用样式的元素的class属性同时包含。比如，元素要应用 .important.stress {background: silver;} ，则其class属性的值至少要包含 important 和 stress。如下所示的元素也能匹配 .important.stress {background: silver;} 多类选择器中的样式：123&lt;p class="important stress warning"&gt;According to the weather forecast, there will be a storm tomorrow.&lt;/p&gt; 3.5 ID选择器ID选择器和类选择器很类似，他们有着以下的差别： ID选择器前面有一个#号 ——— 也称为棋盘号而不是点号。如下所示，这个规则会让id属性为font的所有元素显示为粗体、sans-serif 字体的文本：1234*#font &#123; font-weight: bold; font-family: sans-serif;&#125; 说明：与类选择器一样,ID选择器中的通配选择器通常是被忽略的，所以通常的写法都如下所示：1234#font &#123; font-weight: bold; font-family: sans-serif;&#125; ID选择器不引用class属性的值，对比于类选择器，毫无疑问，它要引用id属性中的值。如下所示：12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="content-type" content="text/html" charset="utf-8"&gt; &lt;title&gt;ID选择器示例&lt;/title&gt; &lt;style type="text/css"&gt; #font &#123; font-weight: bold; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 id="font"&gt;My maxim&lt;/h1&gt; &lt;p&gt;Ba all you can be!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 类选择器和ID选择器的区别： 相同点：可以应用到任何元素。 不同点： 在一个HTML文档中，ID选择器仅允许使用一次；而类选择器可以使用多次。 ID选择器不能结合使用，因为ID属性不允许有以空格分隔的词列表；而类选择器class属性可以通过词列表为一个元素同时设置多个样式。 ID能包含更多含义。有些情况下，您知道文档中会出现某个特定 ID 值，但是并不知道它会出现在哪个元素上，所以您想声明独立的 ID 选择器。例如，您可能知道在一个给定的文档中会有一个 ID 值为 mostImportant 的元素。您不知道这个最重要的东西是一个段落、一个短语、一个列表项还是一个小节标题。您只知道每个文档都会有这么一个最重要的内容，它可能在任何元素中，而且只能出现一个。在这种情况下，可以编写如下规则：1234#mostImportant &#123; color:red; background:yellow;&#125; 注意：类选择器和ID选择器可能是区分大小写的，这取决于文档语言。HTML和XHTML将类和ID值定义为区分大小写，所以类和ID的大小写必须与文档中的相应值匹配。因此，下面元素中的元素h1不会变成粗体： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="content-type" content="text/html" charset="utf-8"&gt; &lt;title&gt;ID选择器示例&lt;/title&gt; &lt;style type="text/css"&gt; #font &#123; font-weight: bold; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 id="Font"&gt;My maxim&lt;/h1&gt; &lt;p&gt;Ba all you can be!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 由于字母 f 的大小写不同，所以选择器不会匹配上面的元素。 3.6 属性选择器对于类选择器和ID选择器，在使用的时候，我们只是设置适当的属性值。因为，这些属性是某些标记语言（例如HTML、SVG、MathML）的元素本来就具备的。可能在其他标记语言中，这些类和ID选择器就不能使用了。所以，CSS2引入属性选择器，这样，我们就可以通过自定义元素属性并为其设置值来选择元素，而不仅限于class 和 id 属性。CSS 共有4种类型的属性选择器，分别是 简单属性选择器 、具体属性选择器 、部分属性选择器 、特定属性选择器。 3.6.1 根据简单属性选择如果只考虑选择有某个属性的元素，而不论该属性的值是什么，可以使用简单选择器。例如，要选择有title属性（值不限）的所有p元素，可以写作：123h1[title] &#123; color: silver;&#125; 根据简单属性选择的例子还有很多，例如可以只对有href属性的锚（a元素）应用样式：123a[href] &#123; color: red;&#125; 此外，还可以根据多个属性进行选择，只需将属性选择器链接在一起即可。例如，为了将同时有 href 和 title 属性的 HTML 超链接的文本设为粗体，可以这样写：123a[href][title] &#123; font-weight: bold;&#125; 还可以采用一些创造性的方法使用这个特性。例如，可以对所有带 alt 属性的图像应用某种样式，从而判断图像是否有效：123img[alt] &#123; border: 3px solid red;&#125; 3.6.2 根据具体属性值选择相比于简单选择器的对象是某些属性整体，具体属性选择器进一步缩小选择范围，只选择有特定属性值的元素，使得元素的选择更加具体。例如，上面的例子我们针对所有带 alt 属性的图像应用了某种样式，现在我们具体到只对 alt=&quot;动漫&quot; 的图片应用样式，判断这类的图像是否有效：123img[alt="动漫"] &#123; border: 3px solid red;&#125; 同样，跟简单属性选择器一样，我们可以把多个属性-值选择器链接在一起来选择一个文档。例如，为了将 title=&quot;音乐&quot; 且 href=&quot;http://music.163.com/&quot; 的所以 HTML 超链接的文本加粗并设为红色，可以这样写：1234a[href="http://music.163.com/"][title="音乐"] &#123; font-weight: bold; color: red;&#125; 注意：在使用具体属性选择器时，一定要注意 属性与属性值必须完全匹配 。尤其要注意属性值包含空格的值列表，这种情况下的匹配很容易出问题。例如：1&lt;a type="audio music" href="http://music.163.com/"&gt;网易云音乐&lt;/a&gt; 要根据具体属性正确地匹配上面这个元素，唯一的写法是：1234a[type="audio music"] &#123;font-weight: bold;color: red;&#125; 3.6.3 根据部分属性值选择如果属性能接受词列表，可以根据其中的任意一个词进行选择。也就是说，对于属性包含多个词的元素，使用部分选择器可以根据其中的某个词来进行选择。例如，我们想选择 class 属性包含 coding 的 p 元素，就可以用部分属性选择器做到：123p[class~="coding"] &#123; font-weight: bold;&#125; 上面的样式就可以使 class 属性包含 coding 的 p 元素的文本为粗体，这些 p 元素可以是：123&lt;p class="coding java"&gt;I love Java&lt;/p&gt;&lt;p class="coding css"class&gt;I use CSS&lt;/p&gt;&lt;p class="student coding vue"&gt;Vue is useful&lt;/p&gt; 注意：使用部分选择器必须注意不要忽略波浪号（~）。如果忽略，则说明需要完成完全值匹配。 在某些情况下，部分属性选择器等价于我们在类选择器中讨论过的点号类名记法。也就是说， p.coding 和 p[class=&quot;coding&quot;] 应用于 HTML 时是等价的。 子串匹配属性选择器部分属性选择器还有一个更高级的选择器模块，它是 CSS2 完成之后发布的，其中包含了更多的部分值属性选择器。按照规范的说法，应该称之为 “子串匹配属性选择器” 。下表是对这些选择器的简单总结： 例如，如果希望对指向 music.163 的所有链接应用样式，不必为所有这些链接指定 class，再根据这个类编写样式，而只需编写以下规则：123a[href*="music.163.com"] &#123; color: red;&#125; 3.6.4 特定属性选择类型特定属性选择器的使用如下所示：123*[lang|="en"] &#123; color: blue;&#125; 上面的规则会选择 lang 属性等于 en 或者以 en- 开头的所有元素。也就是说属性[att|=value]的(比如 ·lang=”en-us”)含义就是：匹配值为“value”或者以“value”开始并立即跟上一个“-”字符，也就是“value-”的 att 属性。 3.7 派生选择器CSS语法中通过依据元素在其位置的上下文关系来定义样式，这样可以使标记更加简洁。在CSS1中，通过这种方式来应用规则的选择器被称为上下文选择器，这是由于它们依赖于上下文关系来应用或者避免某项规则。在CSS2中，它们称为派生选择器，但是无论你如何称呼它们，它们的作用都是相同的。派生选择器允许你根据文档的上下文关系来确定某个标签的样式。通过合理地使用派生选择器，我们可以使HTML代码变得更加整洁。CSS 中，派生选择器包括： 后代选择器 、子元素选择器 、相邻兄弟选择器。 3.7.1 后代选择器后代选择器，其语法：规则左边的选择器由两个或多个用空格分隔的元素组成。并且，这些元素之间是有继承关系的，一般越靠左的元素在继承树中越是 辈份 高。后代选择器，也就是将规则作用于某元素的后代元素。例如:123h1 em &#123; color: gray;&#125; 上面的规则会将 h1 元素后代的 em 元素的文本变成灰色。 注意：关于后代选择器，构成后代关系的两个元素之间的层次间隔可以是无限的。例如, ul em , 这个选择器会将规则应用于从 ul 元素继承的所有 em 元素， 而不论 em 的嵌套层次多深。如下所示：123456789101112131415161718&lt;ul&gt; &lt;li&gt;List item 1 &lt;ol&gt; &lt;li&gt;List item 1-1&lt;/li&gt; &lt;li&gt;List item 1-2&lt;/li&gt; &lt;li&gt;List item 1-3 &lt;ol&gt; &lt;li&gt;List item 1-3-1&lt;/li&gt; &lt;li&gt;List item &lt;em&gt;1-3-2&lt;/em&gt;&lt;/li&gt; &lt;li&gt;List item 1-3-3&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;List item 1-4&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;List item 2&lt;/li&gt; &lt;li&gt;List item 3&lt;/li&gt;&lt;/ul&gt; 3.7.2 子元素选择器与后代选择器不同，子元素选择器只能选择作为某元素子元素的元素。也就是说，后代选择器将规则作用于父类元素的后代，这个后代可以是直接的子元素，也可以是隔代的元素；而子元素选择器是将规则作用于父类元素直接的子元素。例如：123h1 &gt; strong &#123;color:red;&#125; 可以看出，子元素选择器是在两个元素之间使用了子结合符，即大于号（&gt;）。子结合符两边可以有空白符，因此，h1 &gt; strong 、h1&gt; strong 和 h1&gt;strong 都是一样的。 为了详细说明子元素选择器的使用，举个例子。下面的两个 h1 元素都有嵌套了 &lt;strong&gt; ，但只有第一个 h1 元素中的 &lt;strong&gt; 样式作用成功了，而第二个 h1 中的 &lt;strong&gt; 不受影响。这是因为第一个 h1 元素中的 strong 是 h1 的直接子类,而第二个 h1 中的 &lt;strong&gt; 是 &lt;em&gt; 直接的子元素， 是 h1 的后代。12&lt;h1&gt;This is &lt;strong&gt;very&lt;/strong&gt; &lt;strong&gt;very&lt;/strong&gt; important.&lt;/h1&gt;&lt;h1&gt;This is &lt;em&gt;really &lt;strong&gt;very&lt;/strong&gt;&lt;/em&gt; important.&lt;/h1&gt; 3.7.3 相邻兄弟选择器如果需要选择紧接在另一个元素后的元素，而且二者有相同的父元素，可以使用相邻兄弟选择器。例如,如果要增加紧接在 h1 元素后出现的段落的上边距，可以这样写：123h1 + p &#123; margin-top:50px;&#125; 相邻兄弟选择器使用了加号（+），即相邻兄弟结合符。与子结合符一样，相邻兄弟结合符旁边可以有空白符。 注意：使用相邻兄弟选择器时要注意，用一个结合符只能选择两个相邻兄弟中的第二个元素。因为在定义中，使用相邻选择器是 选择紧接在另一个元素后的元素 且 二者有相同的父元素。例如：12345678910111213141516171819li + li &#123;font-weight:bold;&#125;``` 上面这个选择器只会把列表中的第二个和第三个列表项变为粗体。第一个列表项不受影响。 ```HTML&lt;div&gt; &lt;ul&gt; &lt;li&gt;List item 1&lt;/li&gt; &lt;li&gt;List item 2&lt;/li&gt; &lt;li&gt;List item 3&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;List item 1&lt;/li&gt; &lt;li&gt;List item 2&lt;/li&gt; &lt;li&gt;List item 3&lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 3.8 伪类选择器在解释伪类选择器之前，我们先来弄清楚 伪类 和 伪元素。 伪类 ：表示一些元素的动态状态，用于向某些选择器添加特殊的效果，典型的就是链接的各个状态(LVHA)。 伪元素 ：用于将特殊的效果添加到某些选择器，代表了某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中。 CSS中常用的伪类如下所示（包括CSS、CSS2）： 使用伪类选择器的语法是：123selector : pseudo-class &#123; property: value;&#125; 与CSS类结合使用的语法是：123selector.class : pseudo-class &#123; property: value;&#125; CSS 中最常用的伪类是锚伪类，它可以分为 链接伪类 、动态伪类。 链接伪类： 12a:link &#123;color: #FF0000;&#125; /* 未访问的链接 */a:visited &#123;color: #00FF00;&#125; /* 已访问的链接 */ 动态伪类：根据用户行为改变文档的外观，可以应用到任何元素。 12a:hover &#123;color: #FF00FF;&#125; /* 鼠标移动到链接上 */a:active &#123;color: #0000FF;&#125; /* 选定的链接 */ 提示：在CSS中，伪类的使用是有顺序的。一般建议按 link-visited-hover-active (LVHA) 的顺序声明。 在 CSS2.1 中，还定义了 :focus 、:first-child 、:lang()： :focus ：指示当前拥有输入焦点的元素。例如，下面的规则可以突出显示一个准备接受键盘输入的表单元素。 1234input:focus &#123; background: silver; font-weight: bold;&#125; :first-child ：选择元素的第一个子元素。也就是在其他元素内选择第一个该元素，而不是该元素的第一个子元素。 123456789&lt;div&gt;&lt;p&gt;These are the necessary steps:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Intert Key&lt;/li&gt;&lt;li&gt;Turn key &lt;strong&gt;clockwise&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;Push accelerator&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Do &lt;em&gt;not&lt;/em&gt; push the brake at the same time as the accelerator.&lt;/p&gt;&lt;/div&gt; 上面的 HTML 文件，作为第一个子元素的元素包括第一个 p 、第一个 li 和 strong 及 em 元素。给定一下规则：123456p:first-child &#123; font-weight: bold;&#125;li:first-child &#123; text-transform: uppercase;&#125; 其最终的效果是： :lang() ：:lang() 伪类就像是 |= 属性选择器，可以为不同的语言定义特殊的规则。例如，把所有的法语元素变成斜体，可以写作：123*:lang(fr) &#123; font-style: italic;&#125; 3.9 伪元素选择器CSS中常用的伪元素如下所示（包括CSS、CSS2）： 与伪类的语法一样，使用伪元素选择器的语法是：123selector : pseudo-element &#123; property: value;&#125; 与CSS类结合使用的语法是：123selector.class : pseudo-element &#123; property: value;&#125; CSS2.1中的定义了4个常用的伪元素：:first-line 、:first-letter 、:before 、:after。 :first-line ：可以用来影响元素中第一个文本行。例如，可以让文档中第一段的第一行变成粉色： 123p::first-line &#123;&#125; :first-letter ：用于设置一个块级元素首字母的样式，而且仅对该字母设置样式。例如，下面的规则会把每一段的第一个字母变成红色： 123p::first-letter &#123; color: red;&#125; :before :可以在元素的内容前面插入新内容。例如，在每个 h1 元素前面插入一幅图片： 123h1:before &#123; content:url(logo.gif);&#125; :after ：可以在元素的内容之后插入新内容。例如，在文档的最后用一个适当的结束语结束： 123body:after &#123; content:" The End.";&#125; 注意： 可以应用到伪元素 :first-line 和 :first-letter 的属性是有限制的。 所有伪元素都必须放在出现该伪元素的选择器的最后面。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS学习笔记（一）]]></title>
      <url>%2F2016%2F12%2F04%2FCSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[引言 最近刚好在学CSS，所以这篇博客主要是记录我跟着《CSS权威指南》学习CSS过程中的一些知识点。这样，学完之后，把一些知识点记录下来，除了加深记忆，也方便以后复习。 一、认识CSS首先，先简单的描述一下CSS。CSS 语言是一种标记语言,因此不需要编译，可以直接由浏览器执行 ( 属于浏览器解释型语言 )。CSS 全称为“层叠样式表 (Cascading Style Sheets)”，它主要是用于定义HTML内容在浏览器内的显示样式，如文字大小、颜色、字体加粗等，它有着以下的优点： 内容与表现分离 ：使用CSS+HTML，网页的内容(HTML)与表现(CSS)就可以分开了。CSS独立于HTML文件，可以方便维护与复用。 表现的统一 ：使用CSS来控制网页的内容，可以使网页的表现非常的统一，并且容易修改。 良好的扩展性 ：CSS可以支持多种设备，比如手机、PAD、打印机、游戏机等。 缩减文件大小 ：使用CSS可以减少网页的代码量，增加网页的浏览速度，减少硬盘容量。 二、CSS基础知识2.1 一些基本术语在开始学习CSS之前，我们首先需要理解以下的概念 ：元素 是文档结构的基础。在HTML中，元素就是标签。例如，p、div 、span 。文档中的每个元素都对文档的表现起一定的作用。而在CSS中，元素分为两类：块级元素 、行内元素。 替换和非替换元素 ： 替换元素 ：指元素的具体显示内容是由浏览器根据元素的标签和属性来决定。例如，img标签是通过src属性的值来读取相应的图片信息并显示图片。 非替换元素 ：指直接将要显示的内容告诉浏览器，将其显示出来。例如，p标签，浏览器会将标签中的内容直接显示出来。 块级和行内元素 ： 块级元素 ：在HTML中, &lt;div&gt; 、&lt;p&gt; 、&lt;h1&gt; 、&lt;form&gt; 、&lt;ul&gt; 、 &lt;li&gt; 就是块级元素。 块级元素的特点： 每个块级元素都从新的一行开始，并且其后的元素也另起一行。（也就是说，一个块级元素独占一行）； 元素的高度、宽度、行高以及顶和底边距都可设置； 元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。 行内元素 ：在HTML中，&lt;span&gt; 、&lt;a&gt; 、&lt;strong&gt; 和 &lt;em&gt; 就是典型的 内联元素(行内元素)。 说明：div、h1 或 p 元素常常被称为块级元素。这意味着这些元素显示为一块内容，即“块框”。与之相反，span 和 strong 等元素称为“行内元素”，这是因为它们的内容显示在行中，即“行内框”。可以使用 display 属性改变生成的框的类型。这意味着，通过将 display 属性设置为 block，可以让行内元素（比如 a 元素）表现得像块级元素一样。还可以通过把 display 设置为 none，让生成的元素根本没有框。这样的话，该框及其所有内容就不再显示，不占用文档中的空间。 行内元素的特点： 和其他元素都在一行上； 元素的高度、宽度及顶部和底部边距不可设置； 元素的宽度就是它包含的文字或图片的宽度，不可改变。 块级元素和行内元素被称为CSS的显示元素。显示元素也可被分为三类，即： 块级元素 内联元素(行内元素) 内联块状元素 (inline-block) ：就是同时具备内联元素、块状元素的特点。 内联块状元素的特点： 和其他元素都在一行上； 元素的高度、宽度、行高以及顶和底边距都可设置。 2.2 CSS语法CSS规则由 选择器 和 声明 组成，而声明又由属性和值组成，如下图所示： 选择器： 又称选择符，通常是网页中你要应用样式规则的元素。 声明： 在英文大括号“｛｝”中的的就是声明，每条声明由一个属性和一个值组成。每个属性有一个值。属性和值被冒号分开。如下所示：1p &#123;font-size:14px;color:blue;&#125; 在这个例子中，p是选择器，font-size和color是属性，14px和blue是值。 注意： 图片所示的CSS规则，最后一条属性结尾没有添加分号，这种做法是可行的。但是为了以后修改方便，一般都会加上分号。 为了使样式更加容易阅读，在一条规则有多重声明时，可以将每条代码写在一个新行内，如下所示：1234p&#123; font-size: 14px; color: red;&#125; 关键字： 一条声明中，属性的后面，用空格分隔的这些词就是关键字，这些关键字在一起构成了属性的值。大多数情况下，属性的值要么是一个关键字，要么是该属性可取关键字的一个列表(包含一个或多个关键字)，关键字之间用空格分隔。 注意：如果声明中使用了不正确的属性或者不正确的值，整个声明都会被忽略。 2.3 CSS样式表基本知识既然已经知道了CSS在网页内容表现中的作用，那在HTML页面中，到底CSS样式是写在哪里的呢？从CSS样式代码插入的形式来看，基本上可以分为以下三种：内联式、嵌入式、外部式。接下来，我们分别来了解着三种形式，以及CSS中的多重样式。 2.3.1 CSS样式1. 内联式CSS样式内联式CSS样式表 就是把CSS代码直接写在现有的HTML标签中，即在相关的标签内使用样式（style）属性。Style 属性可以包含任何 CSS 属性。如下面的代码所示：123&lt;p style="color:red;margin-left:20px"&gt; You can do best.&lt;/p&gt; 注意：由于要将表现和内容混杂在一起，内联样式会损失掉样式表的许多优势。请慎用这种方法，例如当样式仅需要在一个元素上应用一次时。 2. 嵌入式CSS样式嵌入式CSS样式表 就是把CSS代码写在标签之间，如下所示：1234567&lt;head&gt;&lt;style type="text/css"&gt; hr &#123;color: sienna;&#125; p &#123;margin-left: 20px;&#125; body &#123;background-image: url("images/hello.png");&#125;&lt;/style&gt;&lt;/head&gt; 注意：嵌入式CSS样式一般是当单个文档需要特殊的样式时使用，并且包含CSS样式的 &lt;style&gt; 标签一般是写在文档的头部 &lt;head&gt; 标签之间。 除了在 &lt;style&gt; 标记之间包含多个CSS规则，也可以通过 @import 指令来引入多个外部式样式表，如下所示：12345&lt;style type="text/css"&gt; @import url(style.css); /*这条指令必须在其他的CSS规则前，否则将不起作用*/ h1 &#123;color: gray;&#125; p &#123;font-size: 12px;color: red;&#125;&lt;/style&gt; 注意：@import 指令与 link 类似，其用于Web浏览器加载一个外部样式表，并在表现HTML文档时应用这个外部样式。唯一的区别在于指令的具体语法和位置。@import 指令出现在 style 容器中，而且必须要位于其他CSS规则之前，否则，指令所引入的样式表将不起作用。 3. 外部式CSS样式外部式CSS样式表 也称为(外联式)，就是把CSS代码写在一个单独的外部CSS文件中，这个CSS文件以 .css 为扩展名，在 &lt;head&gt; 内（不是在 &lt;style&gt; 标签内）使用 &lt;link&gt; 标签将CSS样式文件链接到HTMl文件内。如下面的代码所示：1&lt;link href="base.css" rel="stylesheet" type="text/css" /&gt; 在 link 标记中，有三个常用的属性 href、rel、type。其中，href 的值是样式表的 URL，可以是绝对 URL，也可以是相对 URL；rel 代表“关系（relation）”，在这里它的值是 stylesheet；type 表明了使用link标签加载的数据的类型，它的值总是设置为“text/css”。 浏览器会加载外部CSS文件 base.css，从中读到样式声明，并根据它来格式文档。 注意： 当样式需要应用于很多页面时，外部样式表将是理想的选择。在使用外部样式表的情况下，你可以通过改变一个文件来改变整个站点的外观。 外部CSS文件不能包含任何的 html 标签，只能有CSS规则和CSS注释。因为如果一个外部样式表中出现了 html 标签，会导致其中一部分或全部被忽略。 不要在属性值与单位之间留有空格。例如：“font-size:14px;”，而不能写成“font-size:14 px”。 2.3.2 多重样式如果某些属性在不同的样式表中被同样的选择器定义，那么属性值将从更具体的样式表中被继承过来。例如，外部式样式表 “base.css” 针对h3选择器有如下规则：12345h3 &#123; color: red; text-align: left; font-size: 14px;&#125; 而嵌入式样式表中针对h3选择器的规则是：1234h3 &#123; text-align: right; font-size: 20px;&#125; 假如一个页面同时应用了外部式样式表和嵌入式样式表，那么，h3最后的样式是：12345h3 &#123; color: red; text-align: right; font-size: 20px;&#125; 即最终，h3选择器的颜色属性将应用外部式样式表中的规则，而文字排列和字体尺寸会应用嵌入式样式表中的规则。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo+Github 搭建自己的博客]]></title>
      <url>%2F2016%2F11%2F09%2FGithub%2BHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页. 一.准备工作安装Hexo非常简单,但在安装Hexo之前,我们必须确保已经安装下列应用程序: Node.js Git 1.1 安装Git客户端之所以首先安装 Git,是因为安装了 Git 客户端之后,我们就可以通过 git 命令的方式来安装 Node.js. 在Git官网下载了 Git 的 Windows 客户端之后,我们只需要按照提示就完成安装即可. 1.2 安装Node.js安装 Node.js有两种方法,这两种方法分别是: 下载安装程序安装 去Node.js官网下载 Node.js 的安装程序,下载完成之后,安装过程中,只需要一路next即可完成安装. 使用 nvm 安装(推荐) 在 Windows 桌面任意位置鼠标右键,在指定目录下选择 Git Bash Here,输入以下命令: $ curl https://raw.github.com/creationix/nvm/master/install.sh sh 安装完成后，重启终端并执行下列命令即可安装 Node.js $ nvm install stable 1.3 注册Github账号在Github官网注册帐号,完成注册之后,进行下面的操作: 给账号添加 SSH Key 生成 SSH Key 在 Git Bash 上键入以下命令:ssh-keygen -t rsa -C &quot;xxx@xx.com&quot; 其中xxx@xx.com是你注册github的邮箱 在成功生成 SSH Key 之后,我们在系统-&gt;用户文件夹下,找到一个 .ssh的文件夹,将一个 id_rsa.pub 的文件中的内容拷贝; 添加 SSH Key 到Github 账号 在Github任意页面,点击自己的头像,选择 Settings-&gt; SSH keys-&gt;New SSH key ,为 SSH Key 添加合适的 Title,并把之前 id_rsa.pub 中的内容复制到 Key,点击 Add SSH key即完成添加. 新建 repository (仓库) 登录 Github, 点击 “New Repository”,新建一个版本库 输入仓库名,yourname.github.io(yourname与你的注册用户名一致,这个就是你博客的域名了) 接下来,我们打开刚才新建的版本库,点击右边的“Setting”菜单进入设置 然后,找到并点击 “Launch automatic page generator” 新打开页面之后点击底部的”Continue to layouts” 之后选择一个随意模版,点击”Publish page”,发布github默认生成的一个静态站点 接着打开在 github 上的静态网址, http://yourname.github.io ,你会打开刚才选择静态站点模版的网页. 二.搭建博客2.1 安装Hexo在安装了所有必备的应用程序后，即可使用 npm 安装 Hexo.在任意目录下新建Blog文件夹,在文件夹下右键,选择 “Git Bash Here”,然后键下面的命令: $ npm install -g hexo-cli 软件安装完成之后,我们可以通过命令的形式来验证软件是否安装成功.打开 Windows 命令行,输入以下命令可以查看相应的软件是否安装成功: git --version 查看 Git 客户端是否安装成功 node -v 查看 Node.js 是否安装成功 npm -v 查看 npm(即Node的包管理工具) 是否安装成功 等安装完毕,通过输入 hexo -v的命令来测试 Hexo 是否安装成功,成功如下图展示: 2.2 本地运行Hexo 初始化Hexo hexo init 安装依赖文件 npm install 如果上述命令长时间无法执行成功,可以考虑更换国内的 npm 镜像,具体可搜索 npm 换源 部署形成文件 hexo generate 在之后,我们就可以通过下面命令 hexo s -g 在浏览器里打开 http://localhost:4000, 就可以在本地预览自己的个人博客了 2.3 修改Hexo配置文件 修改hexo配置文件 _config.yml 在Blog的hexo目录下,打开配置文件_config.yml 修改配置文件 _config.yml,编辑字段 deploy 关于配置文件 _config.yml其他的修改,一般除了基本的设置,都是根据自己的主题来设置.这里我使用的是一款非常流行的主题next,该主题的配置文件修改可以到 next 的Github主页去参考配置. 2.4 安装 hexo git插件 npm install hexo-deployer-git --save 2.5 将本地Hexo主题部署到Github 部署本地主题到Github，需要执行以下的命令: hexo clean hexo generator 可以简写成 hexo g hexo deploy 可以简写成 hexo d 每次修改本地主题，都需要执行上述命令,只有这样主题才能在 Github 上生效 执行完命令之后,我们就可以输入自己的域名来查看部署到 Github 的博客了;我的博客使用了 next 的主题 三.发布自己的第一篇博客 要发布博客,首先需要在 hexo 的 source-&gt;_posts文件夹下新建一个 .md 格式的文档,该格式的文档是一种标记语言 Markdown来编辑. 3.1 使用 Atom(一款可以编辑 Markdown语言的编辑器)编辑博客 如下图所示,在 Atom上使用 Markdown编辑博客 3.2 发布博客 在指定目录下编辑好博文之后,在 hexo 目录下执行下面的命令就可以发布博客到 Github hexo clean hexo d -g 效果:]]></content>
    </entry>

    
  
  
</search>
